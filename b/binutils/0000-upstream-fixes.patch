diff --git a/bfd/ChangeLog b/bfd/ChangeLog
index 417ed273ab..c8bcf8eabe 100644
--- a/bfd/ChangeLog
+++ b/bfd/ChangeLog
@@ -1,3 +1,110 @@
+2017-11-24  Alan Modra  <amodra@gmail.com>
+
+	Apply from master
+	2017-11-14  Alan Modra  <amodra@gmail.com>
+	PR 22431
+	* elf64-ppc.c (ppc64_elf_size_dynamic_sections): Warn on discarding
+	non-empty dynamic section.
+	(ppc_build_one_stub): Take elf_gp from output bfd, not output
+	section owner.
+	(ppc_size_one_stub, ppc64_elf_next_toc_section): Likewise.
+
+2017-11-05  Alan Modra  <amodra@gmail.com>
+
+	PR 22397
+	* bfd.c (_bfd_doprnt_scan): Check args index before storing, not
+	after.
+
+2017-11-05  Alan Modra  <amodra@gmail.com>
+
+	PR 22397
+	* bfd.c (union _bfd_doprnt_args): New.
+	(PRINT_TYPE): Add FIELD arg.  Take value from args.
+	(_bfd_doprnt): Replace ap parameter with args.  Adjust all
+	PRINT_TYPE invocations and reading of format args to suit.
+	Move "%%" handling out of switch handling args.  Support
+	positional parameters.
+	(_bfd_doprnt_scan): New function.
+	(error_handler_internal): Call _bfd_doprnt_scan and read args.
+
+2017-11-05  Alan Modra  <amodra@gmail.com>
+
+	Apply from master
+	2017-10-11  Pedro Alves  <palves@redhat.com>
+	* bfd.c (_doprnt): Rename to ...
+	(_bfd_doprnt): ... this.
+	(error_handler_internal): Adjust.
+
+2017-11-01  Alan Modra  <amodra@gmail.com>
+
+	Apply from master
+	2017-10-30  Alan Modra  <amodra@gmail.com>
+	* elf32-frv.c (ELF_TARGET_ID): Don't define for generic
+	elf target.
+
+	2017-10-30  Alan Modra  <amodra@gmail.com>
+	* elflink.c (elf_gc_sweep): Test elf_object_id in addition to
+	relocs_compatible.
+	(bfd_elf_gc_sections): Likewise.
+
+	2017-10-28  Alan Modra  <amodra@gmail.com>
+	PR 22300
+	* elflink.c (_bfd_elf_merge_symbol): Remove relocs_compatible check.
+	* elf32-hppa.c (elf_backend_relocs_compatible): Define.
+	* elf32-ppc.c (elf_backend_relocs_compatible): Define.
+	* elf64-ppc.c (elf_backend_relocs_compatible): Define.
+
+	2017-10-25  Alan Modra  <amodra@gmail.com>
+	* archive.c (_bfd_compute_and_write_armap): Match "__gnu_lto_slim"
+	optionally prefixed with "_".
+	* linker.c (_bfd_generic_link_add_one_symbol): Likewise.
+
+2017-10-05  Alan Modra  <amodra@gmail.com>
+
+	* elflink.c (elf_link_input_bfd): Correct ctor/dtor in init_array/
+	fini_array error value.
+
+2017-10-04  Pavel I. Kryukov <kryukov@frtk.ru>
+
+	PR 22245
+	* bfd.c (bfd_set_error): Avoid UB on passing arg to va_start that
+	undergoes default promotion.
+	* bfd-in2.h: Regenerate.
+
+2017-09-28  Alan Modra  <amodra@gmail.com>
+
+	PR 22220
+	* elflink.c (_bfd_elf_merge_symbol): Set non_ir_ref_dynamic in
+	a case where plugin_notice isn't called.
+
+2017-09-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR ld/22199
+	* elf64-x86-64.c (elf_x86_64_finish_dynamic_symbol): Don't pass
+	output_bfd to info->callbacks->minfo.
+
+2017-09-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR binutils/22170
+	* elf32-i386.c (elf_i386_get_synthetic_symtab): Guard against
+	corrupted PLT.
+	* elf64-x86-64.c (elf_x86_64_get_synthetic_symtab): Likewise.
+
+2017-09-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR binutils/22163
+	* elf32-i386.c (elf_i386_get_synthetic_symtab): Also return -1
+	if bfd_canonicalize_dynamic_reloc returns 0.
+	* elf64-x86-64.c (elf_x86_64_get_synthetic_symtab): Likewise.
+
+2017-09-21  Nick Clifton  <nickc@redhat.com>
+
+	* development.sh (development): Revert previous delta.
+
+2017-09-20  Nick Clifton  <nickc@redhat.com>
+
+	* development.sh (development): Set to false.
+
 2017-09-19  Nick Clifton  <nickc@redhat.com>
 
 	2.29.1 Release
diff --git a/bfd/archive.c b/bfd/archive.c
index 885bf489c0..af964ad19a 100644
--- a/bfd/archive.c
+++ b/bfd/archive.c
@@ -2405,7 +2405,11 @@ _bfd_compute_and_write_armap (bfd *arch, unsigned int elength)
 			  map = new_map;
 			}
 
-		      if (strcmp (syms[src_count]->name, "__gnu_lto_slim") == 0)
+		      if (syms[src_count]->name[0] == '_'
+			  && syms[src_count]->name[1] == '_'
+			  && strcmp (syms[src_count]->name
+				     + (syms[src_count]->name[2] == '_'),
+				     "__gnu_lto_slim") == 0)
 			_bfd_error_handler
 			  (_("%B: plugin needed to handle lto object"),
 			   current);
diff --git a/bfd/bfd-in2.h b/bfd/bfd-in2.h
index 1343780c8c..0dba68b1e6 100644
--- a/bfd/bfd-in2.h
+++ b/bfd/bfd-in2.h
@@ -7053,7 +7053,7 @@ bfd_error_type;
 
 bfd_error_type bfd_get_error (void);
 
-void bfd_set_error (bfd_error_type error_tag, ...);
+void bfd_set_error (int error_tag, ...);
 
 const char *bfd_errmsg (bfd_error_type error_tag);
 
diff --git a/bfd/bfd.c b/bfd/bfd.c
index 665f182559..3e882297e0 100644
--- a/bfd/bfd.c
+++ b/bfd/bfd.c
@@ -497,7 +497,7 @@ FUNCTION
 	bfd_set_error
 
 SYNOPSIS
-	void bfd_set_error (bfd_error_type error_tag, ...);
+	void bfd_set_error (int error_tag, ...);
 
 DESCRIPTION
 	Set the BFD error condition to be @var{error_tag}.
@@ -507,7 +507,7 @@ DESCRIPTION
 */
 
 void
-bfd_set_error (bfd_error_type error_tag, ...)
+bfd_set_error (int error_tag, ...)
 {
   bfd_error = error_tag;
   if (error_tag == bfd_error_on_input)
@@ -611,24 +611,47 @@ CODE_FRAGMENT
 
 static const char *_bfd_error_program_name;
 
-/* This macro and _doprnt taken from libiberty _doprnt.c, tidied a
-   little and extended to handle '%A' and '%B'.  'L' as a modifer for
-   integer formats is used for bfd_vma and bfd_size_type args, which
-   vary in size depending on BFD configuration.  */
+/* Support for positional parameters.  */
 
-#define PRINT_TYPE(TYPE) \
+union _bfd_doprnt_args
+{
+  int i;
+  long l;
+  long long ll;
+  double d;
+  long double ld;
+  void *p;
+  enum
+  {
+    Int,
+    Long,
+    LongLong,
+    Double,
+    LongDouble,
+    Ptr
+  } type;
+};
+
+/* This macro and _bfd_doprnt taken from libiberty _doprnt.c, tidied a
+   little and extended to handle '%A', '%B' and positional parameters.
+   'L' as a modifer for integer formats is used for bfd_vma and
+   bfd_size_type args, which vary in size depending on BFD
+   configuration.  */
+
+#define PRINT_TYPE(TYPE, FIELD) \
   do								\
     {								\
-      TYPE value = va_arg (ap, TYPE);				\
+      TYPE value = (TYPE) args[arg_no].FIELD;			\
       result = fprintf (stream, specifier, value);		\
     } while (0)
 
 static int
-_doprnt (FILE *stream, const char *format, va_list ap)
+_bfd_doprnt (FILE *stream, const char *format, union _bfd_doprnt_args *args)
 {
   const char *ptr = format;
   char specifier[128];
   int total_printed = 0;
+  unsigned int arg_count = 0;
 
   while (*ptr != '\0')
     {
@@ -644,39 +667,75 @@ _doprnt (FILE *stream, const char *format, va_list ap)
 	    result = fprintf (stream, "%s", ptr);
 	  ptr += result;
 	}
+      else if (ptr[1] == '%')
+	{
+	  fputc ('%', stream);
+	  result = 1;
+	  ptr += 2;
+	}
       else
 	{
 	  /* We have a format specifier!  */
 	  char *sptr = specifier;
 	  int wide_width = 0, short_width = 0;
+	  unsigned int arg_no;
 
 	  /* Copy the % and move forward.  */
 	  *sptr++ = *ptr++;
 
+	  /* Check for a positional parameter.  */
+	  arg_no = -1u;
+	  if (*ptr != '0' && ISDIGIT (*ptr) && ptr[1] == '$')
+	    {
+	      arg_no = *ptr - '1';
+	      ptr += 2;
+	    }
+
 	  /* Move past flags.  */
 	  while (strchr ("-+ #0", *ptr))
 	    *sptr++ = *ptr++;
 
 	  if (*ptr == '*')
 	    {
-	      int value = abs (va_arg (ap, int));
-	      sptr += sprintf (sptr, "%d", value);
+	      int value;
+	      unsigned int arg_index;
+
 	      ptr++;
+	      arg_index = arg_count;
+	      if (*ptr != '0' && ISDIGIT (*ptr) && ptr[1] == '$')
+		{
+		  arg_index = *ptr - '1';
+		  ptr += 2;
+		}
+	      value = abs (args[arg_index].i);
+	      arg_count++;
+	      sptr += sprintf (sptr, "%d", value);
 	    }
 	  else
 	    /* Handle explicit numeric value.  */
 	    while (ISDIGIT (*ptr))
 	      *sptr++ = *ptr++;
 
+	  /* Precision.  */
 	  if (*ptr == '.')
 	    {
 	      /* Copy and go past the period.  */
 	      *sptr++ = *ptr++;
 	      if (*ptr == '*')
 		{
-		  int value = abs (va_arg (ap, int));
-		  sptr += sprintf (sptr, "%d", value);
+		  int value;
+		  unsigned int arg_index;
+
 		  ptr++;
+		  arg_index = arg_count;
+		  if (*ptr != '0' && ISDIGIT (*ptr) && ptr[1] == '$')
+		    {
+		      arg_index = *ptr - '1';
+		      ptr += 2;
+		    }
+		  value = abs (args[arg_index].i);
+		  arg_count++;
+		  sptr += sprintf (sptr, "%d", value);
 		}
 	      else
 		/* Handle explicit numeric value.  */
@@ -705,6 +764,8 @@ _doprnt (FILE *stream, const char *format, va_list ap)
 	  /* Copy the type specifier, and NULL terminate.  */
 	  *sptr++ = *ptr++;
 	  *sptr = '\0';
+	  if ((int) arg_no < 0)
+	    arg_no = arg_count;
 
 	  switch (ptr[-1])
 	    {
@@ -720,12 +781,12 @@ _doprnt (FILE *stream, const char *format, va_list ap)
 		   as an int and trust the C library printf to cast it
 		   to the right width.  */
 		if (short_width)
-		  PRINT_TYPE (int);
+		  PRINT_TYPE (int, i);
 		else
 		  {
 		    /* L modifier for bfd_vma or bfd_size_type may be
 		       either long long or long.  */
-		    if (sptr[-2] == 'L')
+		    if (ptr[-2] == 'L')
 		      {
 			sptr[-2] = 'l';
 			if (BFD_ARCH_SIZE < 64 || BFD_HOST_64BIT_LONG)
@@ -741,10 +802,10 @@ _doprnt (FILE *stream, const char *format, va_list ap)
 		    switch (wide_width)
 		      {
 		      case 0:
-			PRINT_TYPE (int);
+			PRINT_TYPE (int, i);
 			break;
 		      case 1:
-			PRINT_TYPE (long);
+			PRINT_TYPE (long, l);
 			break;
 		      case 2:
 		      default:
@@ -756,10 +817,10 @@ _doprnt (FILE *stream, const char *format, va_list ap)
 			*sptr = '\0';
 #endif
 #if defined (__GNUC__) || defined (HAVE_LONG_LONG)
-			PRINT_TYPE (long long);
+			PRINT_TYPE (long long, ll);
 #else
 			/* Fake it and hope for the best.  */
-			PRINT_TYPE (long);
+			PRINT_TYPE (long, l);
 #endif
 			break;
 		      }
@@ -773,35 +834,32 @@ _doprnt (FILE *stream, const char *format, va_list ap)
 	    case 'G':
 	      {
 		if (wide_width == 0)
-		  PRINT_TYPE (double);
+		  PRINT_TYPE (double, d);
 		else
 		  {
 #if defined (__GNUC__) || defined (HAVE_LONG_DOUBLE)
-		    PRINT_TYPE (long double);
+		    PRINT_TYPE (long double, ld);
 #else
 		    /* Fake it and hope for the best.  */
-		    PRINT_TYPE (double);
+		    PRINT_TYPE (double, d);
 #endif
 		  }
 	      }
 	      break;
 	    case 's':
-	      PRINT_TYPE (char *);
+	      PRINT_TYPE (char *, p);
 	      break;
 	    case 'p':
-	      PRINT_TYPE (void *);
-	      break;
-	    case '%':
-	      fputc ('%', stream);
-	      result = 1;
+	      PRINT_TYPE (void *, p);
 	      break;
 	    case 'A':
 	      {
-		asection *sec = va_arg (ap, asection *);
+		asection *sec;
 		bfd *abfd;
 		const char *group = NULL;
 		struct coff_comdat_info *ci;
 
+		sec = (asection *) args[arg_no].p;
 		if (sec == NULL)
 		  /* Invoking %A with a null section pointer is an
 		     internal error.  */
@@ -825,8 +883,9 @@ _doprnt (FILE *stream, const char *format, va_list ap)
 	      break;
 	    case 'B':
 	      {
-		bfd *abfd = va_arg (ap, bfd *);
+		bfd *abfd;
 
+		abfd = (bfd *) args[arg_no].p;
 		if (abfd == NULL)
 		  /* Invoking %B with a null bfd pointer is an
 		     internal error.  */
@@ -842,6 +901,7 @@ _doprnt (FILE *stream, const char *format, va_list ap)
 	    default:
 	      abort();
 	    }
+	  arg_count++;
 	}
       if (result == -1)
 	return -1;
@@ -851,15 +911,230 @@ _doprnt (FILE *stream, const char *format, va_list ap)
   return total_printed;
 }
 
+/* First pass over FORMAT to gather ARGS.  Returns number of args.  */
+
+static unsigned int
+_bfd_doprnt_scan (const char *format, union _bfd_doprnt_args *args)
+{
+  const char *ptr = format;
+  unsigned int arg_count = 0;
+
+  while (*ptr != '\0')
+    {
+      if (*ptr != '%')
+	{
+	  ptr = strchr (ptr, '%');
+	  if (ptr == NULL)
+	    break;
+	}
+      else if (ptr[1] == '%')
+	ptr += 2;
+      else
+	{
+	  int wide_width = 0, short_width = 0;
+	  unsigned int arg_no;
+
+	  ptr++;
+
+	  /* Check for a positional parameter.  */
+	  arg_no = -1u;
+	  if (*ptr != '0' && ISDIGIT (*ptr) && ptr[1] == '$')
+	    {
+	      arg_no = *ptr - '1';
+	      ptr += 2;
+	    }
+
+	  /* Move past flags.  */
+	  while (strchr ("-+ #0", *ptr))
+	    ptr++;
+
+	  if (*ptr == '*')
+	    {
+	      unsigned int arg_index;
+
+	      ptr++;
+	      arg_index = arg_count;
+	      if (*ptr != '0' && ISDIGIT (*ptr) && ptr[1] == '$')
+		{
+		  arg_index = *ptr - '1';
+		  ptr += 2;
+		}
+	      if (arg_index >= 9)
+		abort ();
+	      args[arg_index].type = Int;
+	      arg_count++;
+	    }
+	  else
+	    /* Handle explicit numeric value.  */
+	    while (ISDIGIT (*ptr))
+	      ptr++;
+
+	  /* Precision.  */
+	  if (*ptr == '.')
+	    {
+	      ptr++;
+	      if (*ptr == '*')
+		{
+		  unsigned int arg_index;
+
+		  ptr++;
+		  arg_index = arg_count;
+		  if (*ptr != '0' && ISDIGIT (*ptr) && ptr[1] == '$')
+		    {
+		      arg_index = *ptr - '1';
+		      ptr += 2;
+		    }
+		  if (arg_index >= 9)
+		    abort ();
+		  args[arg_index].type = Int;
+		  arg_count++;
+		}
+	      else
+		/* Handle explicit numeric value.  */
+		while (ISDIGIT (*ptr))
+		  ptr++;
+	    }
+	  while (strchr ("hlL", *ptr))
+	    {
+	      switch (*ptr)
+		{
+		case 'h':
+		  short_width = 1;
+		  break;
+		case 'l':
+		  wide_width++;
+		  break;
+		case 'L':
+		  wide_width = 2;
+		  break;
+		default:
+		  abort();
+		}
+	      ptr++;
+	    }
+
+	  ptr++;
+	  if ((int) arg_no < 0)
+	    arg_no = arg_count;
+
+	  if (arg_no >= 9)
+	    abort ();
+	  switch (ptr[-1])
+	    {
+	    case 'd':
+	    case 'i':
+	    case 'o':
+	    case 'u':
+	    case 'x':
+	    case 'X':
+	    case 'c':
+	      {
+		if (short_width)
+		  args[arg_no].type = Int;
+		else
+		  {
+		    if (ptr[-2] == 'L')
+		      {
+			if (BFD_ARCH_SIZE < 64 || BFD_HOST_64BIT_LONG)
+			  wide_width = 1;
+		      }
+
+		    switch (wide_width)
+		      {
+		      case 0:
+			args[arg_no].type = Int;
+			break;
+		      case 1:
+			args[arg_no].type = Long;
+			break;
+		      case 2:
+		      default:
+#if defined (__GNUC__) || defined (HAVE_LONG_LONG)
+			args[arg_no].type = LongLong;
+#else
+			args[arg_no].type = Long;
+#endif
+			break;
+		      }
+		  }
+	      }
+	      break;
+	    case 'f':
+	    case 'e':
+	    case 'E':
+	    case 'g':
+	    case 'G':
+	      {
+		if (wide_width == 0)
+		  args[arg_no].type = Double;
+		else
+		  {
+#if defined (__GNUC__) || defined (HAVE_LONG_DOUBLE)
+		    args[arg_no].type = LongDouble;
+#else
+		    args[arg_no].type = Double;
+#endif
+		  }
+	      }
+	      break;
+	    case 's':
+	    case 'p':
+	    case 'A':
+	    case 'B':
+	      args[arg_no].type = Ptr;
+	      break;
+	    default:
+	      abort();
+	    }
+	  arg_count++;
+	}
+    }
+
+  return arg_count;
+}
+
 /* This is the default routine to handle BFD error messages.
    Like fprintf (stderr, ...), but also handles some extra format specifiers.
 
-   %A section name from section.  For group components, print group name too.
-   %B file name from bfd.  For archive components, prints archive too.  */
+   %A section name from section.  For group components, prints group name too.
+   %B file name from bfd.  For archive components, prints archive too.
+
+   Beware: Only supports a maximum of 9 format arguments.  */
 
 static void
 error_handler_internal (const char *fmt, va_list ap)
 {
+  int i, arg_count;
+  union _bfd_doprnt_args args[9];
+
+  arg_count = _bfd_doprnt_scan (fmt, args);
+  for (i = 0; i < arg_count; i++)
+    {
+      switch (args[i].type)
+	{
+	case Int:
+	  args[i].i = va_arg (ap, int);
+	  break;
+	case Long:
+	  args[i].l = va_arg (ap, long);
+	  break;
+	case LongLong:
+	  args[i].ll = va_arg (ap, long long);
+	  break;
+	case Double:
+	  args[i].d = va_arg (ap, double);
+	  break;
+	case LongDouble:
+	  args[i].ld = va_arg (ap, long double);
+	  break;
+	case Ptr:
+	  args[i].p = va_arg (ap, void *);
+	  break;
+	default:
+	  abort ();
+	}
+    }
+
   /* PR 4992: Don't interrupt output being sent to stdout.  */
   fflush (stdout);
 
@@ -868,7 +1143,7 @@ error_handler_internal (const char *fmt, va_list ap)
   else
     fprintf (stderr, "BFD: ");
 
-  _doprnt (stderr, fmt, ap);
+  _bfd_doprnt (stderr, fmt, args);
 
   /* On AIX, putc is implemented as a macro that triggers a -Wunused-value
      warning, so use the fputc function to avoid it.  */
diff --git a/bfd/elf32-frv.c b/bfd/elf32-frv.c
index ef609ff540..67b3c6a9eb 100644
--- a/bfd/elf32-frv.c
+++ b/bfd/elf32-frv.c
@@ -6773,7 +6773,6 @@ elf32_frv_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
   return TRUE;
 }
 #define ELF_ARCH		bfd_arch_frv
-#define ELF_TARGET_ID		FRV_ELF_DATA
 #define ELF_MACHINE_CODE	EM_CYGNUS_FRV
 #define ELF_MAXPAGESIZE		0x1000
 
@@ -6812,6 +6811,8 @@ elf32_frv_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
 
 #include "elf32-target.h"
 
+#undef ELF_TARGET_ID
+#define ELF_TARGET_ID		FRV_ELF_DATA
 #undef ELF_MAXPAGESIZE
 #define ELF_MAXPAGESIZE		0x4000
 
diff --git a/bfd/elf32-hppa.c b/bfd/elf32-hppa.c
index 548d656776..62a689ae5e 100644
--- a/bfd/elf32-hppa.c
+++ b/bfd/elf32-hppa.c
@@ -4615,6 +4615,7 @@ elf32_hppa_elf_get_symbol_type (Elf_Internal_Sym *elf_sym, int type)
 #define elf_backend_adjust_dynamic_symbol    elf32_hppa_adjust_dynamic_symbol
 #define elf_backend_copy_indirect_symbol     elf32_hppa_copy_indirect_symbol
 #define elf_backend_check_relocs	     elf32_hppa_check_relocs
+#define elf_backend_relocs_compatible	     _bfd_elf_relocs_compatible
 #define elf_backend_create_dynamic_sections  elf32_hppa_create_dynamic_sections
 #define elf_backend_fake_sections	     elf_hppa_fake_sections
 #define elf_backend_relocate_section	     elf32_hppa_relocate_section
diff --git a/bfd/elf32-i386.c b/bfd/elf32-i386.c
index 5c1c3ff790..ba50c93f33 100644
--- a/bfd/elf32-i386.c
+++ b/bfd/elf32-i386.c
@@ -6342,7 +6342,7 @@ elf_i386_get_synthetic_symtab (bfd *abfd,
 
   dynrelcount = bfd_canonicalize_dynamic_reloc (abfd, dynrelbuf,
 						dynsyms);
-  if (dynrelcount < 0)
+  if (dynrelcount <= 0)
     return -1;
 
   /* Sort the relocs by address.  */
@@ -6616,6 +6616,10 @@ bad_return:
 		  size += sizeof ("+0x") - 1 + 8;
 		n++;
 		s++;
+		/* There should be only one entry in PLT for a given
+		   symbol.  Set howto to NULL after processing a PLT
+		   entry to guard against corrupted PLT.  */
+		p->howto = NULL;
 	      }
 	    offset += plt_entry_size;
 	  }
diff --git a/bfd/elf32-ppc.c b/bfd/elf32-ppc.c
index f9a32c2e87..3f42f2a4d8 100644
--- a/bfd/elf32-ppc.c
+++ b/bfd/elf32-ppc.c
@@ -10931,6 +10931,7 @@ ppc_elf_finish_dynamic_sections (bfd *output_bfd,
 #define elf_backend_relocate_section		ppc_elf_relocate_section
 #define elf_backend_create_dynamic_sections	ppc_elf_create_dynamic_sections
 #define elf_backend_check_relocs		ppc_elf_check_relocs
+#define elf_backend_relocs_compatible		_bfd_elf_relocs_compatible
 #define elf_backend_copy_indirect_symbol	ppc_elf_copy_indirect_symbol
 #define elf_backend_adjust_dynamic_symbol	ppc_elf_adjust_dynamic_symbol
 #define elf_backend_add_symbol_hook		ppc_elf_add_symbol_hook
diff --git a/bfd/elf64-ppc.c b/bfd/elf64-ppc.c
index 277bb0ef5d..e2d4ba15e5 100644
--- a/bfd/elf64-ppc.c
+++ b/bfd/elf64-ppc.c
@@ -101,6 +101,7 @@ static bfd_vma opd_entry_value
 #define elf_backend_notice_as_needed	      ppc64_elf_notice_as_needed
 #define elf_backend_archive_symbol_lookup     ppc64_elf_archive_symbol_lookup
 #define elf_backend_check_relocs	      ppc64_elf_check_relocs
+#define elf_backend_relocs_compatible	      _bfd_elf_relocs_compatible
 #define elf_backend_gc_keep		      ppc64_elf_gc_keep
 #define elf_backend_gc_mark_dynamic_ref       ppc64_elf_gc_mark_dynamic_ref
 #define elf_backend_gc_mark_hook	      ppc64_elf_gc_mark_hook
@@ -10328,6 +10329,10 @@ ppc64_elf_size_dynamic_sections (bfd *output_bfd,
 	  continue;
 	}
 
+      if (bfd_is_abs_section (s->output_section))
+	_bfd_error_handler (_("warning: discarding dynamic section %s"),
+			    s->name);
+
       if ((s->flags & SEC_HAS_CONTENTS) == 0)
 	continue;
 
@@ -11122,7 +11127,7 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
 	      + htab->brlt->output_section->vma);
 
       off = (dest
-	     - elf_gp (htab->brlt->output_section->owner)
+	     - elf_gp (info->output_bfd)
 	     - htab->sec_info[stub_entry->group->link_sec->id].toc_off);
 
       if (off + 0x80008000 > 0xffffffff || (off & 7) != 0)
@@ -11273,7 +11278,7 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
 	}
 
       off = (dest
-	     - elf_gp (plt->output_section->owner)
+	     - elf_gp (info->output_bfd)
 	     - htab->sec_info[stub_entry->group->link_sec->id].toc_off);
 
       if (off + 0x80008000 > 0xffffffff || (off & 7) != 0)
@@ -11421,7 +11426,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
 	plt = htab->elf.iplt;
       off += (plt->output_offset
 	      + plt->output_section->vma
-	      - elf_gp (plt->output_section->owner)
+	      - elf_gp (info->output_bfd)
 	      - htab->sec_info[stub_entry->group->link_sec->id].toc_off);
 
       size = plt_stub_size (htab, stub_entry, off);
@@ -11524,7 +11529,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
 	  off = (br_entry->offset
 		 + htab->brlt->output_offset
 		 + htab->brlt->output_section->vma
-		 - elf_gp (htab->brlt->output_section->owner)
+		 - elf_gp (info->output_bfd)
 		 - htab->sec_info[stub_entry->group->link_sec->id].toc_off);
 
 	  if (info->emitrelocations)
@@ -11644,7 +11649,7 @@ ppc64_elf_next_toc_section (struct bfd_link_info *info, asection *isec)
 	 output toc base plus 0x8000.  Making the input elf_gp an
 	 offset allows us to move the toc as a whole without
 	 recalculating input elf_gp.  */
-      off = htab->toc_curr - elf_gp (isec->output_section->owner);
+      off = htab->toc_curr - elf_gp (info->output_bfd);
       off += TOC_BASE_OFF;
 
       /* Die if someone uses a linker script that doesn't keep input
@@ -11673,7 +11678,7 @@ ppc64_elf_next_toc_section (struct bfd_link_info *info, asection *isec)
     }
   addr = (htab->toc_first_sec->output_offset
 	  + htab->toc_first_sec->output_section->vma);
-  off = addr - elf_gp (isec->output_section->owner) + TOC_BASE_OFF;
+  off = addr - elf_gp (info->output_bfd) + TOC_BASE_OFF;
   elf_gp (isec->owner) = off;
 
   return TRUE;
diff --git a/bfd/elf64-x86-64.c b/bfd/elf64-x86-64.c
index 80dd791d25..1f6dfb89bf 100644
--- a/bfd/elf64-x86-64.c
+++ b/bfd/elf64-x86-64.c
@@ -6133,7 +6133,6 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,
 	      if (SYMBOL_REFERENCES_LOCAL (info, h))
 		{
 		  info->callbacks->minfo (_("Local IFUNC function `%s' in %B\n"),
-					  output_bfd,
 					  h->root.root.string,
 					  h->root.u.def.section->owner);
 
@@ -6717,7 +6716,7 @@ elf_x86_64_get_synthetic_symtab (bfd *abfd,
 
   dynrelcount = bfd_canonicalize_dynamic_reloc (abfd, dynrelbuf,
 						dynsyms);
-  if (dynrelcount < 0)
+  if (dynrelcount <= 0)
     return -1;
 
   /* Sort the relocs by address.  */
@@ -6970,6 +6969,10 @@ bad_return:
 		  size += sizeof ("+0x") - 1 + 8 + 8 * ABI_64_P (abfd);
 		n++;
 		s++;
+		/* There should be only one entry in PLT for a given
+		   symbol.  Set howto to NULL after processing a PLT
+		   entry to guard against corrupted PLT.  */
+		p->howto = NULL;
 	      }
 	    offset += plt_entry_size;
 	  }
diff --git a/bfd/elflink.c b/bfd/elflink.c
index 02713a5956..9e0c1bb2c7 100644
--- a/bfd/elflink.c
+++ b/bfd/elflink.c
@@ -1161,11 +1161,6 @@ _bfd_elf_merge_symbol (bfd *abfd,
   if (pold_weak)
     *pold_weak = oldweak;
 
-  /* This code is for coping with dynamic objects, and is only useful
-     if we are doing an ELF link.  */
-  if (!(*bed->relocs_compatible) (abfd->xvec, info->output_bfd->xvec))
-    return TRUE;
-
   /* We have to check it for every instance since the first few may be
      references and not all compilers emit symbol type for undefined
      symbols.  */
@@ -1234,6 +1229,16 @@ _bfd_elf_merge_symbol (bfd *abfd,
       olddyn = (oldsec->symbol->flags & BSF_DYNAMIC) != 0;
     }
 
+  /* Handle a case where plugin_notice won't be called and thus won't
+     set the non_ir_ref flags on the first pass over symbols.  */
+  if (oldbfd != NULL
+      && (oldbfd->flags & BFD_PLUGIN) != (abfd->flags & BFD_PLUGIN)
+      && newdyn != olddyn)
+    {
+      h->root.non_ir_ref_dynamic = TRUE;
+      hi->root.non_ir_ref_dynamic = TRUE;
+    }
+
   /* NEWDEF and OLDDEF indicate whether the new or old symbol,
      respectively, appear to be a definition rather than reference.  */
 
@@ -10429,7 +10434,7 @@ elf_link_input_bfd (struct elf_final_link_info *flinfo, bfd *input_bfd)
 		    (_("error: %B: size of section %A is not "
 		       "multiple of address size"),
 		     input_bfd, o);
-		  bfd_set_error (bfd_error_on_input);
+		  bfd_set_error (bfd_error_bad_value);
 		  return FALSE;
 		}
 	      o->flags |= SEC_ELF_REVERSE_COPY;
@@ -13018,6 +13023,7 @@ elf_gc_sweep (bfd *abfd, struct bfd_link_info *info)
       asection *o;
 
       if (bfd_get_flavour (sub) != bfd_target_elf_flavour
+	  || elf_object_id (sub) != elf_hash_table_id (elf_hash_table (info))
 	  || !(*bed->relocs_compatible) (sub->xvec, abfd->xvec))
 	continue;
       o = sub->sections;
@@ -13346,6 +13352,7 @@ bfd_elf_gc_sections (bfd *abfd, struct bfd_link_info *info)
       asection *o;
 
       if (bfd_get_flavour (sub) != bfd_target_elf_flavour
+	  || elf_object_id (sub) != elf_hash_table_id (htab)
 	  || !(*bed->relocs_compatible) (sub->xvec, abfd->xvec))
 	continue;
 
diff --git a/bfd/linker.c b/bfd/linker.c
index 72d5705e63..a96c6ed1dd 100644
--- a/bfd/linker.c
+++ b/bfd/linker.c
@@ -1403,7 +1403,9 @@ _bfd_generic_link_add_one_symbol (struct bfd_link_info *info,
     {
       row = COMMON_ROW;
       if (!bfd_link_relocatable (info)
-	  && strcmp (name, "__gnu_lto_slim") == 0)
+	  && name[0] == '_'
+	  && name[1] == '_'
+	  && strcmp (name + (name[2] == '_'), "__gnu_lto_slim") == 0)
 	_bfd_error_handler
 	  (_("%B: plugin needed to handle lto object"), abfd);
     }
diff --git a/bfd/version.h b/bfd/version.h
index 3405e424f4..1fef3e059a 100644
--- a/bfd/version.h
+++ b/bfd/version.h
@@ -1,4 +1,4 @@
-#define BFD_VERSION_DATE 20170919
+#define BFD_VERSION_DATE 20171218
 #define BFD_VERSION @bfd_version@
 #define BFD_VERSION_STRING  @bfd_version_package@ @bfd_version_string@
 #define REPORT_BUGS_TO @report_bugs_to@
diff --git a/binutils/ChangeLog b/binutils/ChangeLog
index 84d3d7c1c4..6856b61e86 100644
--- a/binutils/ChangeLog
+++ b/binutils/ChangeLog
@@ -1,3 +1,14 @@
+2017-11-01  Alan Modra  <amodra@gmail.com>
+
+	Apply from master
+	2017-10-25  Alan Modra  <amodra@gmail.com>
+	* nm.c (filter_symbols): Match "__gnu_lto_slim" optionally prefixed
+	with "_".
+
+2017-09-21  Maciej W. Rozycki  <macro@imgtec.com>
+
+	* readelf.c (get_machine_flags) <E_MIPS_MACH_5900>: New case.
+
 2017-09-15  Nick Clifton  <nickc@redhat.com>
 
 	2.29.1 Release
diff --git a/binutils/nm.c b/binutils/nm.c
index 7ddcc8a113..2d8866ceda 100644
--- a/binutils/nm.c
+++ b/binutils/nm.c
@@ -480,7 +480,9 @@ filter_symbols (bfd *abfd, bfd_boolean is_dynamic, void *minisyms,
       if (sym == NULL)
 	bfd_fatal (bfd_get_filename (abfd));
 
-      if (strcmp (sym->name, "__gnu_lto_slim") == 0)
+      if (sym->name[0] == '_'
+	  && sym->name[1] == '_'
+	  && strcmp (sym->name + (sym->name[2] == '_'), "__gnu_lto_slim") == 0)
 	non_fatal (_("%s: plugin needed to handle lto object"),
 		   bfd_get_filename (abfd));
 
diff --git a/binutils/readelf.c b/binutils/readelf.c
index fb16df8e2a..41f128ed23 100644
--- a/binutils/readelf.c
+++ b/binutils/readelf.c
@@ -3325,6 +3325,7 @@ get_machine_flags (unsigned e_flags, unsigned e_machine)
 	    case E_MIPS_MACH_4650: strcat (buf, ", 4650"); break;
 	    case E_MIPS_MACH_5400: strcat (buf, ", 5400"); break;
 	    case E_MIPS_MACH_5500: strcat (buf, ", 5500"); break;
+	    case E_MIPS_MACH_5900: strcat (buf, ", 5900"); break;
 	    case E_MIPS_MACH_SB1:  strcat (buf, ", sb1");  break;
 	    case E_MIPS_MACH_9000: strcat (buf, ", 9000"); break;
   	    case E_MIPS_MACH_LS2E: strcat (buf, ", loongson-2e"); break;
diff --git a/gas/ChangeLog b/gas/ChangeLog
index 42a676f598..6eb20f0b86 100644
--- a/gas/ChangeLog
+++ b/gas/ChangeLog
@@ -1,3 +1,23 @@
+2017-12-12  Alan Modra  <amodra@gmail.com>
+
+	PR 21118
+	* config/tc-ppc.c (md_assemble): Don't mask register number.
+
+2017-11-01  Alan Modra  <amodra@gmail.com>
+
+	Apply from master
+	2017-10-25  Alan Modra  <amodra@gmail.com>
+	PR 22348
+	* config/tc-crx.c (instruction, output_opcode): Make static.
+	(relocatable, ins_parse, cur_arg_num): Likewise.
+	(parse_insn): Adjust for renamed opcodes globals.
+	(check_range): Likewise
+
+2017-09-21  Maciej W. Rozycki  <macro@imgtec.com>
+
+	* testsuite/gas/mips/elf_mach_5900.d: New test.
+	* testsuite/gas/mips/mips.exp: Run it.
+
 2017-09-15  Nick Clifton  <nickc@redhat.com>
 
 	2.29.1 Release
diff --git a/gas/config/tc-crx.c b/gas/config/tc-crx.c
index be0d455587..c5a21441b5 100644
--- a/gas/config/tc-crx.c
+++ b/gas/config/tc-crx.c
@@ -69,21 +69,21 @@ static struct hash_control *reg_hash;
 /* CRX coprocessor registers hash table.  */
 static struct hash_control *copreg_hash;
 /* Current instruction we're assembling.  */
-const inst *instruction;
+static const inst *instruction;
 
 /* Global variables.  */
 
 /* Array to hold an instruction encoding.  */
-long output_opcode[2];
+static long output_opcode[2];
 
 /* Nonzero means a relocatable symbol.  */
-int relocatable;
+static int relocatable;
 
 /* A copy of the original instruction (used in error messages).  */
-char ins_parse[MAX_INST_LEN];
+static char ins_parse[MAX_INST_LEN];
 
 /* The current processed argument number.  */
-int cur_arg_num;
+static int cur_arg_num;
 
 /* Generic assembler global variables which must be defined by all targets.  */
 
@@ -1043,9 +1043,9 @@ parse_insn (ins *insn, char *operands)
   int i;
 
   /* Handle instructions with no operands.  */
-  for (i = 0; no_op_insn[i] != NULL; i++)
+  for (i = 0; crx_no_op_insn[i] != NULL; i++)
   {
-    if (streq (no_op_insn[i], instruction->mnemonic))
+    if (streq (crx_no_op_insn[i], instruction->mnemonic))
     {
       insn->nargs = 0;
       return;
@@ -1387,7 +1387,7 @@ check_range (long *num, int bits, int unsigned flags, int update)
 		      : instruction->flags & DISPUD4 ? 4
 		      : 0);
 
-      for (bin = 0; bin < cst4_maps; bin++)
+      for (bin = 0; bin < crx_cst4_maps; bin++)
 	{
 	  if (value == mul * bin)
 	    {
@@ -1404,9 +1404,9 @@ check_range (long *num, int bits, int unsigned flags, int update)
     {
       int is_cst4 = 0;
 
-      for (bin = 0; bin < cst4_maps; bin++)
+      for (bin = 0; bin < crx_cst4_maps; bin++)
 	{
-	  if (value == (uint32_t) cst4_map[bin])
+	  if (value == (uint32_t) crx_cst4_map[bin])
 	    {
 	      is_cst4 = 1;
 	      if (update)
diff --git a/gas/config/tc-ppc.c b/gas/config/tc-ppc.c
index e8dfbc4bb6..f0724a3cea 100644
--- a/gas/config/tc-ppc.c
+++ b/gas/config/tc-ppc.c
@@ -2977,7 +2977,7 @@ md_assemble (char *str)
 		   && ex.X_add_number != 0
 		   && (operand->flags & PPC_OPERAND_GPR_0) != 0))
 	    as_warn (_("invalid register expression"));
-	  insn = ppc_insert_operand (insn, operand, ex.X_add_number & 0xff,
+	  insn = ppc_insert_operand (insn, operand, ex.X_add_number,
 				     ppc_cpu, (char *) NULL, 0);
 	}
       else if (ex.X_op == O_constant)
diff --git a/gas/testsuite/gas/mips/elf_mach_5900.d b/gas/testsuite/gas/mips/elf_mach_5900.d
new file mode 100644
index 0000000000..1df668e7e5
--- /dev/null
+++ b/gas/testsuite/gas/mips/elf_mach_5900.d
@@ -0,0 +1,22 @@
+#readelf: -Ah
+#name: ELF R5900 markings
+#as: -32 -march=r5900
+#source: empty.s
+
+ELF Header:
+#...
+  Flags: +0x..92...., .*5900.*
+#...
+
+MIPS ABI Flags Version: 0
+
+ISA: MIPS3
+GPR size: 32
+CPR1 size: 32
+CPR2 size: 0
+FP ABI: .*
+ISA Extension: Toshiba R5900
+ASEs:
+	None
+FLAGS 1: .*
+FLAGS 2: .*
diff --git a/gas/testsuite/gas/mips/mips.exp b/gas/testsuite/gas/mips/mips.exp
index c71dca4351..25221ae2af 100644
--- a/gas/testsuite/gas/mips/mips.exp
+++ b/gas/testsuite/gas/mips/mips.exp
@@ -1149,6 +1149,7 @@ if { [istarget mips*-*-vxworks*] } {
     run_dump_test "elf_ase_micromips-2"
 
     # Verify that machine markings are handled properly.
+    run_dump_test "elf_mach_5900"
     run_dump_test "elf_mach_interaptiv-mr2"
 
     run_dump_test "mips-gp32-fp32-pic"
diff --git a/gold/ChangeLog b/gold/ChangeLog
index 6071f8977a..9e45ad360d 100644
--- a/gold/ChangeLog
+++ b/gold/ChangeLog
@@ -1,3 +1,76 @@
+2017-12-01  Cary Coutant  <ccoutant@gmail.com>
+
+	PR gold/22309
+	* testsuite/Makefile.am (two_file_test_1_v1_ndebug.o): Compile with
+	no EH information.
+	(two_file_test_1_ndebug.o): Likewise.
+	* testsuite/Makefile.in: Regenerate.
+	* testsuite/two_file_test_1.cc: Touch to force recompilation with new
+	flags.
+	* testsuite/two_file_test_1_v1.cc: Likewise.
+
+2017-11-30  Peter Smith  <peter.smith@linaro.org>
+
+	PR gold/20765
+	* aarch64.cc (Aarch64_relobj::update_erratum_address): New method.
+	(AArch64_relobj::scan_errata): Update addresses in stub table after
+	relaxation pass.
+
+2017-11-30  Peter Smith  <peter.smith@linaro.org>
+	    Cary Coutant  <ccoutant@gmail.com>
+
+	PR gold/20765
+	* aarch64.cc (Erratum_stub::invalidate_erratum_stub): Use erratum_insn_
+	instead of relobj_ to invalidate the stub.
+	(Erratum_stub::is_invalidated_erratum_stub): Likewise.
+
+2017-11-30  Peter Smith  <peter.smith@linaro.org>
+
+	PR gold/22233
+	* aarch64.cc (AArch64_relobj::fix_errata_and_relocate_erratum_stubs):
+	Fix calculation of stub address.
+
+2017-11-21  Ian Lance Taylor  <iant@google.com>
+
+	Apply from master:
+	2017-11-19  Ian Lance Taylor  <iant@google.com>
+		    Cary Coutant  <ccoutant@gmail.com>
+	* dwarf_reader.h (class Dwarf_info_reader): Add ref_addr_size
+	method.
+	* dwarf_reader.cc (Dwarf_die::read_attributes): Use ref_addr_size
+	for DW_FORM_ref_addr_size.
+	(Dwarf_die::skip_attributes): Likewise.
+
+2017-11-01  Alan Modra  <amodra@gmail.com>
+
+	Apply from master
+	2017-10-25  Alan Modra  <amodra@gmail.com>
+	* symtab.cc (Symbol_table::add_from_relobj): Match "__gnu_lto_slim"
+	optionally prefixed with "_".
+
+2017-10-18  Kyle Butt  <iteratee@google.com>
+	    Alan Modra  <amodra@gmail.com>
+
+	* powerpc.cc (Target_powerpc::Scan::local): Correct dst_off
+	calculation for TOC16 relocs.
+	(Target_powerpc::Scan::global): Likewise.
+
+2017-09-28  Alan Modra  <amodra@gmail.com>
+
+	* powerpc.cc (Target_powerpc<64,*>::powerpc_info): Set
+	is_default_stack_executable false.
+
+2017-08-03  James Clarke  <jrtc27@jrtc27.com>
+
+	* options.h (General_options): Set a non-NULL second help string
+	argument for relax to allow --no-relax.
+
+2017-09-20  Alan Modra  <amodra@gmail.com>
+
+	* powerpc.cc (Target_powerpc::Branch_info::make_stub): Put
+	stubs for ppc32 non-branch relocs in first stub table.
+	(Target_powerpc::Relocate::relocate): Resolve similarly.
+
 2017-09-19  Alan Modra  <amodra@gmail.com>
 
 	* options.h (stub-group-multi): Default to true.  Add
diff --git a/gold/aarch64.cc b/gold/aarch64.cc
index b4287a6f25..c7c9279adb 100644
--- a/gold/aarch64.cc
+++ b/gold/aarch64.cc
@@ -1031,6 +1031,18 @@ public:
   set_erratum_address(AArch64_address addr)
   { this->erratum_address_ = addr; }
 
+  // Later relaxation passes of may alter the recorded erratum and destination
+  // address. Given an up to date output section address of shidx_ in
+  // relobj_ we can derive the erratum_address and destination address.
+  void
+  update_erratum_address(AArch64_address output_section_addr)
+  {
+    const int BPI = AArch64_insn_utilities<big_endian>::BYTES_PER_INSN;
+    AArch64_address updated_addr = output_section_addr + this->sh_offset_;
+    this->set_erratum_address(updated_addr);
+    this->set_destination_address(updated_addr + BPI);
+  }
+
   // Comparator used to group Erratum_stubs in a set by (obj, shndx,
   // sh_offset). We do not include 'type' in the calculation, because there is
   // at most one stub type at (obj, shndx, sh_offset).
@@ -1052,13 +1064,13 @@ public:
   void
   invalidate_erratum_stub()
   {
-     gold_assert(this->relobj_ != NULL);
-     this->relobj_ = NULL;
+     gold_assert(this->erratum_insn_ != invalid_insn);
+     this->erratum_insn_ = invalid_insn;
   }
 
   bool
   is_invalidated_erratum_stub()
-  { return this->relobj_ == NULL; }
+  { return this->erratum_insn_ == invalid_insn; }
 
 protected:
   virtual void
@@ -2041,7 +2053,7 @@ AArch64_relobj<size, big_endian>::fix_errata_and_relocate_erratum_stubs(
           // executed.
           stub_table->relocate_erratum_stub(
 	    stub,
-	    pview.view + view_offset + (stub_table->address() - pview.address));
+	    pview.view + (stub_table->address() - pview.address));
 
           // Next erratum stub.
 	  ++p;
@@ -2304,6 +2316,19 @@ AArch64_relobj<size, big_endian>::scan_errata(
       output_address = poris->address();
     }
 
+  // Update the addresses in previously generated erratum stubs. Unlike when
+  // we scan relocations for stubs, if section addresses have changed due to
+  // other relaxations we are unlikely to scan the same erratum instances
+  // again.
+  The_stub_table* stub_table = this->stub_table(shndx);
+  if (stub_table)
+    {
+      std::pair<Erratum_stub_set_iter, Erratum_stub_set_iter>
+	  ipair(stub_table->find_erratum_stubs_for_input_section(this, shndx));
+      for (Erratum_stub_set_iter p = ipair.first;  p != ipair.second; ++p)
+          (*p)->update_erratum_address(output_address);
+    }
+
   section_size_type input_view_size = 0;
   const unsigned char* input_view =
     this->section_contents(shndx, &input_view_size, false);
diff --git a/gold/dwarf_reader.cc b/gold/dwarf_reader.cc
index 8c0d593752..4da9c1e2be 100644
--- a/gold/dwarf_reader.cc
+++ b/gold/dwarf_reader.cc
@@ -737,7 +737,6 @@ Dwarf_die::read_attributes()
 	      break;
 	    }
 	  case elfcpp::DW_FORM_addr:
-	  case elfcpp::DW_FORM_ref_addr:
 	    {
 	      off_t sec_off;
 	      if (this->dwinfo_->address_size() == 4)
@@ -751,6 +750,20 @@ Dwarf_die::read_attributes()
 	      ref_form = true;
 	      break;
 	    }
+	  case elfcpp::DW_FORM_ref_addr:
+	    {
+	      off_t sec_off;
+	      if (this->dwinfo_->ref_addr_size() == 4)
+		sec_off = this->dwinfo_->read_from_pointer<32>(&pattr);
+	      else
+		sec_off = this->dwinfo_->read_from_pointer<64>(&pattr);
+	      unsigned int shndx =
+		  this->dwinfo_->lookup_reloc(attr_off, &sec_off);
+	      attr_value.aux.shndx = shndx;
+	      attr_value.val.refval = sec_off;
+	      ref_form = true;
+	      break;
+	    }
 	  case elfcpp::DW_FORM_block1:
 	    attr_value.aux.blocklen = *pattr++;
 	    attr_value.val.blockval = pattr;
@@ -947,9 +960,11 @@ Dwarf_die::skip_attributes()
 	    pattr += this->dwinfo_->offset_size();
 	    break;
 	  case elfcpp::DW_FORM_addr:
-	  case elfcpp::DW_FORM_ref_addr:
 	    pattr += this->dwinfo_->address_size();
 	    break;
+	  case elfcpp::DW_FORM_ref_addr:
+	    pattr += this->dwinfo_->ref_addr_size();
+	    break;
 	  case elfcpp::DW_FORM_block1:
 	    pattr += 1 + *pattr;
 	    break;
diff --git a/gold/dwarf_reader.h b/gold/dwarf_reader.h
index b41e057621..31e76ce347 100644
--- a/gold/dwarf_reader.h
+++ b/gold/dwarf_reader.h
@@ -764,6 +764,13 @@ class Dwarf_info_reader
   address_size() const
   { return this->address_size_; }
 
+  // Return the size of a DW_FORM_ref_addr.
+  // In DWARF v2, this was the size of an address; in DWARF v3 and later,
+  // it is the size of an DWARF offset.
+  unsigned int
+  ref_addr_size() const
+  { return this->cu_version_ > 2 ? this->offset_size_ : this->address_size_; }
+
   // Set the section index of the .debug_abbrev section.
   // We use this if there are no relocations for the .debug_info section.
   // If not set, the code parse() routine will search for the section by name.
diff --git a/gold/options.h b/gold/options.h
index 576b2a3c53..4a802cf41f 100644
--- a/gold/options.h
+++ b/gold/options.h
@@ -1164,7 +1164,8 @@ class General_options
 	      N_("Generate relocatable output"), NULL);
 
   DEFINE_bool(relax, options::TWO_DASHES, '\0', false,
-	      N_("Relax branches on certain targets"), NULL);
+	      N_("Relax branches on certain targets"),
+	      N_("Do not relax branches"));
 
   DEFINE_string(retain_symbols_file, options::TWO_DASHES, '\0', NULL,
 		N_("keep only symbols listed in this file"), N_("FILE"));
diff --git a/gold/powerpc.cc b/gold/powerpc.cc
index 629da4f8a1..b5db66549e 100644
--- a/gold/powerpc.cc
+++ b/gold/powerpc.cc
@@ -1618,7 +1618,7 @@ Target::Target_info Target_powerpc<64, true>::powerpc_info =
   false,		// has_make_symbol
   true,			// has_resolve
   false,		// has_code_fill
-  true,			// is_default_stack_executable
+  false,		// is_default_stack_executable
   false,		// can_icf_inline_merge_sections
   '\0',			// wrap_char
   "/usr/lib/ld.so.1",	// dynamic_linker
@@ -1646,7 +1646,7 @@ Target::Target_info Target_powerpc<64, false>::powerpc_info =
   false,		// has_make_symbol
   true,			// has_resolve
   false,		// has_code_fill
-  true,			// is_default_stack_executable
+  false,		// is_default_stack_executable
   false,		// can_icf_inline_merge_sections
   '\0',			// wrap_char
   "/usr/lib/ld.so.1",	// dynamic_linker
@@ -3065,11 +3065,17 @@ Target_powerpc<size, big_endian>::Branch_info::make_stub(
 	target->glink_section()->add_global_entry(gsym);
       else
 	{
-	  if (stub_table == NULL)
+	  if (stub_table == NULL
+	      && !(size == 32
+		   && gsym != NULL
+		   && !parameters->options().output_is_position_independent()
+		   && !is_branch_reloc(this->r_type_)))
 	    stub_table = this->object_->stub_table(this->shndx_);
 	  if (stub_table == NULL)
 	    {
-	      // This is a ref from a data section to an ifunc symbol.
+	      // This is a ref from a data section to an ifunc symbol,
+	      // or a non-branch reloc for which we always want to use
+	      // one set of stubs for resolving function addresses.
 	      stub_table = ifunc_stub_table;
 	    }
 	  gold_assert(stub_table != NULL);
@@ -6643,7 +6649,7 @@ Target_powerpc<size, big_endian>::Scan::local(
 	  shndx = ppc_object->adjust_sym_shndx(r_sym, shndx, &is_ordinary);
 	  if (is_ordinary && shndx == ppc_object->toc_shndx())
 	    {
-	      Address dst_off = lsym.get_st_value() + reloc.get_r_offset();
+	      Address dst_off = lsym.get_st_value() + reloc.get_r_addend();
 	      if (dst_off < ppc_object->section_size(shndx))
 		{
 		  bool ok = false;
@@ -7311,7 +7317,7 @@ Target_powerpc<size, big_endian>::Scan::global(
 	      if (shndx == sym_object->toc_shndx())
 		{
 		  Sized_symbol<size>* sym = symtab->get_sized_symbol<size>(gsym);
-		  Address dst_off = sym->value() + reloc.get_r_offset();
+		  Address dst_off = sym->value() + reloc.get_r_addend();
 		  if (dst_off < sym_object->section_size(shndx))
 		    {
 		      bool ok = false;
@@ -8052,11 +8058,20 @@ Target_powerpc<size, big_endian>::Relocate::relocate(
 	}
       else
 	{
-	  Stub_table<size, big_endian>* stub_table
-	    = object->stub_table(relinfo->data_shndx);
+	  Stub_table<size, big_endian>* stub_table = NULL;
+	  if (target->stub_tables().size() == 1)
+	    stub_table = target->stub_tables()[0];
+	  if (stub_table == NULL
+	      && !(size == 32
+		   && gsym != NULL
+		   && !parameters->options().output_is_position_independent()
+		   && !is_branch_reloc(r_type)))
+	    stub_table = object->stub_table(relinfo->data_shndx);
 	  if (stub_table == NULL)
 	    {
-	      // This is a ref from a data section to an ifunc symbol.
+	      // This is a ref from a data section to an ifunc symbol,
+	      // or a non-branch reloc for which we always want to use
+	      // one set of stubs for resolving function addresses.
 	      if (target->stub_tables().size() != 0)
 		stub_table = target->stub_tables()[0];
 	    }
diff --git a/gold/symtab.cc b/gold/symtab.cc
index 7e0a3f80d2..1b4810ed53 100644
--- a/gold/symtab.cc
+++ b/gold/symtab.cc
@@ -1185,7 +1185,9 @@ Symbol_table::add_from_relobj(
       const char* name = sym_names + st_name;
 
       if (!parameters->options().relocatable()
-	  && strcmp (name, "__gnu_lto_slim") == 0)
+	  && name[0] == '_'
+	  && name[1] == '_'
+	  && strcmp (name + (name[2] == '_'), "__gnu_lto_slim") == 0)
         gold_info(_("%s: plugin needed to handle lto object"),
 		  relobj->name().c_str());
 
diff --git a/gold/testsuite/Makefile.am b/gold/testsuite/Makefile.am
index 26ee77abcc..31c3d3e8a0 100644
--- a/gold/testsuite/Makefile.am
+++ b/gold/testsuite/Makefile.am
@@ -2970,9 +2970,9 @@ pr20976-d.o: pr20976.o gcctestdir/ld
 if DEFAULT_TARGET_X86_64
 
 two_file_test_1_v1_ndebug.o: two_file_test_1_v1.cc
-	$(CXXCOMPILE) -O0 -g0 -c -o $@ $<
+	$(CXXCOMPILE) -O0 -g0 -fno-exceptions -fno-asynchronous-unwind-tables -c -o $@ $<
 two_file_test_1_ndebug.o: two_file_test_1.cc
-	$(CXXCOMPILE) -O0 -g0 -c -o $@ $<
+	$(CXXCOMPILE) -O0 -g0 -fno-exceptions -fno-asynchronous-unwind-tables -c -o $@ $<
 two_file_test_1b_ndebug.o: two_file_test_1b.cc
 	$(CXXCOMPILE) -O0 -g0 -c -o $@ $<
 two_file_test_2_ndebug.o: two_file_test_2.cc
diff --git a/gold/testsuite/Makefile.in b/gold/testsuite/Makefile.in
index eae68b56cb..1ba382e1c9 100644
--- a/gold/testsuite/Makefile.in
+++ b/gold/testsuite/Makefile.in
@@ -7244,9 +7244,9 @@ uninstall-am:
 # Incremental linking is currently supported only on the x86_64 target.
 
 @DEFAULT_TARGET_X86_64_TRUE@@GCC_TRUE@@NATIVE_LINKER_TRUE@two_file_test_1_v1_ndebug.o: two_file_test_1_v1.cc
-@DEFAULT_TARGET_X86_64_TRUE@@GCC_TRUE@@NATIVE_LINKER_TRUE@	$(CXXCOMPILE) -O0 -g0 -c -o $@ $<
+@DEFAULT_TARGET_X86_64_TRUE@@GCC_TRUE@@NATIVE_LINKER_TRUE@	$(CXXCOMPILE) -O0 -g0 -fno-exceptions -fno-asynchronous-unwind-tables -c -o $@ $<
 @DEFAULT_TARGET_X86_64_TRUE@@GCC_TRUE@@NATIVE_LINKER_TRUE@two_file_test_1_ndebug.o: two_file_test_1.cc
-@DEFAULT_TARGET_X86_64_TRUE@@GCC_TRUE@@NATIVE_LINKER_TRUE@	$(CXXCOMPILE) -O0 -g0 -c -o $@ $<
+@DEFAULT_TARGET_X86_64_TRUE@@GCC_TRUE@@NATIVE_LINKER_TRUE@	$(CXXCOMPILE) -O0 -g0 -fno-exceptions -fno-asynchronous-unwind-tables -c -o $@ $<
 @DEFAULT_TARGET_X86_64_TRUE@@GCC_TRUE@@NATIVE_LINKER_TRUE@two_file_test_1b_ndebug.o: two_file_test_1b.cc
 @DEFAULT_TARGET_X86_64_TRUE@@GCC_TRUE@@NATIVE_LINKER_TRUE@	$(CXXCOMPILE) -O0 -g0 -c -o $@ $<
 @DEFAULT_TARGET_X86_64_TRUE@@GCC_TRUE@@NATIVE_LINKER_TRUE@two_file_test_2_ndebug.o: two_file_test_2.cc
diff --git a/gold/testsuite/two_file_test_1.cc b/gold/testsuite/two_file_test_1.cc
index 567409af26..8c26c6344e 100644
--- a/gold/testsuite/two_file_test_1.cc
+++ b/gold/testsuite/two_file_test_1.cc
@@ -20,6 +20,9 @@
 // Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
 // MA 02110-1301, USA.
 
+// For incremental linking tests, this file needs to be compiled with
+// -fno-exceptions -fno-asynchronous-unwind-tables.
+
 // This tests references between files.  This is file 1, and
 // two_file_test_2.cc is file 2.  We test in several different ways:
 
diff --git a/gold/testsuite/two_file_test_1_v1.cc b/gold/testsuite/two_file_test_1_v1.cc
index d2ea0e217a..f95ee737ad 100644
--- a/gold/testsuite/two_file_test_1_v1.cc
+++ b/gold/testsuite/two_file_test_1_v1.cc
@@ -25,6 +25,9 @@
 // source file, then do an incremental link with the primary version of
 // the file.
 
+// For incremental linking tests, this file needs to be compiled with
+// -fno-exceptions -fno-asynchronous-unwind-tables.
+
 // This tests references between files.  This is file 1, and
 // two_file_test_2.cc is file 2.  We test in several different ways:
 
diff --git a/include/ChangeLog b/include/ChangeLog
index 8b25ce724d..239c63e742 100644
--- a/include/ChangeLog
+++ b/include/ChangeLog
@@ -1,3 +1,15 @@
+2017-11-01  Alan Modra  <amodra@gmail.com>
+
+	Apply from master
+	2017-10-25  Alan Modra  <amodra@gmail.com>
+	PR 22348
+	* opcode/cr16.h (instruction): Delete.
+	(cr16_words, cr16_allWords, cr16_currInsn): Delete.
+	* opcode/crx.h (crx_cst4_map): Rename from cst4_map.
+	(crx_cst4_maps): Rename from cst4_maps.
+	(crx_no_op_insn): Rename from no_op_insn.
+	(instruction): Delete.
+
 2017-07-02  Jan Kratochvil  <jan.kratochvil@redhat.com>
 
 	* dwarf2.def (DW_IDX_compile_unit, DW_IDX_type_unit, DW_IDX_die_offset)
diff --git a/include/opcode/cr16.h b/include/opcode/cr16.h
index 80f48dfbfd..4613951d0d 100644
--- a/include/opcode/cr16.h
+++ b/include/opcode/cr16.h
@@ -404,9 +404,6 @@ extern const unsigned int cr16_num_cc;
 /* Table of instructions with no operands.  */
 extern const char * cr16_no_op_insn[];
 
-/* Current instruction we're assembling.  */
-extern const inst *instruction;
-
 /* A macro for representing the instruction "constant" opcode, that is,
    the FIXED part of the instruction. The "constant" opcode is represented
    as a 32-bit unsigned long, where OPC is expanded (by a left SHIFT)
@@ -439,11 +436,6 @@ typedef unsigned long long ULONGLONG;
 typedef unsigned long dwordU;
 typedef unsigned short wordU;
 
-/* Globals to store opcode data and build the instruction.  */
-extern wordU cr16_words[3];
-extern ULONGLONG cr16_allWords;
-extern ins cr16_currInsn;
-
 /* Prototypes for function in cr16-dis.c.  */
 extern void cr16_make_instruction (void);
 extern int  cr16_match_opcode (void);
diff --git a/include/opcode/crx.h b/include/opcode/crx.h
index 23062edf21..7cb5abe610 100644
--- a/include/opcode/crx.h
+++ b/include/opcode/crx.h
@@ -384,14 +384,11 @@ extern const int crx_num_traps;
 #define NUMTRAPS crx_num_traps
 
 /* cst4 operand mapping.  */
-extern const int cst4_map[];
-extern const int cst4_maps;
+extern const int crx_cst4_map[];
+extern const int crx_cst4_maps;
 
 /* Table of instructions with no operands.  */
-extern const char* no_op_insn[];
-
-/* Current instruction we're assembling.  */
-extern const inst *instruction;
+extern const char* crx_no_op_insn[];
 
 /* A macro for representing the instruction "constant" opcode, that is,
    the FIXED part of the instruction. The "constant" opcode is represented
diff --git a/ld/ChangeLog b/ld/ChangeLog
index 73e05b618e..0415ea9777 100644
--- a/ld/ChangeLog
+++ b/ld/ChangeLog
@@ -1,3 +1,25 @@
+2017-11-24  Alan Modra  <amodra@gmail.com>
+
+	Apply from master
+	2017-11-14  Alan Modra  <amodra@gmail.com>
+	* testsuite/ld-elf/note-3.t: Don't discard .got.
+
+2017-11-01  Alan Modra  <amodra@gmail.com>
+
+	Apply from master
+	2017-10-25  Alan Modra  <amodra@gmail.com>
+	* testsuite/ld-plugin/lto-3r.d: Match "__gnu_lto_v" optionally
+	prefixed with "_".
+	* testsuite/ld-plugin/lto-5r.d: Likewise.
+
+2017-09-28  Alan Modra  <amodra@gmail.com>
+
+	* testsuite/ld-plugin/pr22220.h,
+	* testsuite/ld-plugin/pr22220lib.cc,
+	* testsuite/ld-plugin/pr22220lib.ver,
+	* testsuite/ld-plugin/pr22220main.cc: New test.
+	* testsuite/ld-plugin/lto.exp: Run it.
+
 2017-09-19  Nick Clifton  <nickc@redhat.com>
 
 	2.29.1 Release
diff --git a/ld/testsuite/ld-elf/note-3.t b/ld/testsuite/ld-elf/note-3.t
index 13324ae547..4c617d8f2a 100644
--- a/ld/testsuite/ld-elf/note-3.t
+++ b/ld/testsuite/ld-elf/note-3.t
@@ -17,6 +17,7 @@ SECTIONS
   
   .dynstr : { *(.dynstr) }
   .dynsym : { *(.dynsym) }
+  .got : { *(.got .toc) *(.igot) }
   .got.plt : { *(.got.plt) *(.igot.plt) }
   /DISCARD/ : { *(*) }
 }
diff --git a/ld/testsuite/ld-plugin/lto-3r.d b/ld/testsuite/ld-plugin/lto-3r.d
index 1d1befe90f..3726718f2a 100644
--- a/ld/testsuite/ld-plugin/lto-3r.d
+++ b/ld/testsuite/ld-plugin/lto-3r.d
@@ -3,5 +3,5 @@
 #nm: -p
 
 #...
-[0-9a-f]+ C __gnu_lto_v.*
+[0-9a-f]+ C _?__gnu_lto_v.*
 #pass
diff --git a/ld/testsuite/ld-plugin/lto-5r.d b/ld/testsuite/ld-plugin/lto-5r.d
index 43e9a5c5a3..ad1da7047b 100644
--- a/ld/testsuite/ld-plugin/lto-5r.d
+++ b/ld/testsuite/ld-plugin/lto-5r.d
@@ -3,5 +3,5 @@
 #nm: -p
 
 #...
-[0-9a-f]+ C __gnu_lto_v.*
+[0-9a-f]+ C _?__gnu_lto_v.*
 #pass
diff --git a/ld/testsuite/ld-plugin/lto.exp b/ld/testsuite/ld-plugin/lto.exp
index f0bc345f2c..6b7ad536fb 100644
--- a/ld/testsuite/ld-plugin/lto.exp
+++ b/ld/testsuite/ld-plugin/lto.exp
@@ -295,6 +295,12 @@ set lto_link_elf_tests [list \
   [list "Build pr21382.so" \
    "-shared" "-O2 -fpic" \
    {pr21382b.c} {} "pr21382.so" "c"] \
+  [list {Build pr22220lib.so} \
+   {-shared -Wl,--version-script=pr22220lib.ver} {-fPIC} \
+   {pr22220lib.cc} {} {pr22220lib.so} {c++}] \
+  [list {Build pr22220main.o} \
+   {} {-flto} \
+   {pr22220main.cc} {} {} {c++}] \
 ]
 
 # Check final symbols in executables.
@@ -396,6 +402,12 @@ set lto_run_elf_shared_tests [list \
   [list "Run pr21382" \
    "-O2 -flto -fuse-linker-plugin -Wl,--as-needed tmpdir/pr21382a.o tmpdir/pr21382.so" "" \
    {dummy.c} "pr21382.exe" "pass.out" "" "c"] \
+  [list {pr22220a} \
+   {-flto -fuse-linker-plugin tmpdir/pr22220main.o tmpdir/pr22220lib.so} {} \
+   {dummy.c} {pr22220a.exe} {pass.out} {} {c++}] \
+  [list {pr22220b} \
+   {-flto -fuse-linker-plugin -Wl,--no-as-needed tmpdir/pr22220lib.so tmpdir/pr22220main.o} {} \
+   {dummy.c} {pr22220b.exe} {pass.out} {} {c++}] \
 ]
 
 # LTO run-time tests for ELF
diff --git a/ld/testsuite/ld-plugin/pr22220.h b/ld/testsuite/ld-plugin/pr22220.h
new file mode 100644
index 0000000000..b15b45c08d
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr22220.h
@@ -0,0 +1,8 @@
+extern int doo();
+
+inline int *goo() {
+	static int xyz;
+	return &xyz;
+}
+
+int *boo();
diff --git a/ld/testsuite/ld-plugin/pr22220lib.cc b/ld/testsuite/ld-plugin/pr22220lib.cc
new file mode 100644
index 0000000000..771f44f7f3
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr22220lib.cc
@@ -0,0 +1,6 @@
+#include "pr22220.h"
+
+int* boo()
+{
+  return goo ();
+}
diff --git a/ld/testsuite/ld-plugin/pr22220lib.ver b/ld/testsuite/ld-plugin/pr22220lib.ver
new file mode 100644
index 0000000000..6da7e1a2bd
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr22220lib.ver
@@ -0,0 +1 @@
+BAR { global: *; };
diff --git a/ld/testsuite/ld-plugin/pr22220main.cc b/ld/testsuite/ld-plugin/pr22220main.cc
new file mode 100644
index 0000000000..38c206f7a2
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr22220main.cc
@@ -0,0 +1,12 @@
+#include <stdio.h>
+#include "pr22220.h"
+
+int main()
+{
+  if (boo() == goo())
+    {
+      printf ("PASS\n");
+      return 0;
+    }
+  return 1;
+}
diff --git a/opcodes/ChangeLog b/opcodes/ChangeLog
index ab622cafef..9baff278c4 100644
--- a/opcodes/ChangeLog
+++ b/opcodes/ChangeLog
@@ -1,3 +1,18 @@
+2017-11-01  Alan Modra  <amodra@gmail.com>
+
+	Apply from master
+	2017-10-25  Alan Modra  <amodra@gmail.com>
+	PR 22348
+	* cr16-dis.c (cr16_cinvs, instruction, cr16_currInsn): Make static.
+	(cr16_words, cr16_allWords, processing_argument_number): Likewise.
+	(imm4flag, size_changed): Likewise.
+	* crx-dis.c (crx_cinvs, NUMCINVS, instruction, currInsn): Likewise.
+	(words, allWords, processing_argument_number): Likewise.
+	(cst4flag, size_changed): Likewise.
+	* crx-opc.c (crx_cst4_map): Rename from cst4_map.
+	(crx_cst4_maps): Rename from cst4_maps.
+	(crx_no_op_insn): Rename from no_op_insn.
+
 2017-09-15  Nick Clifton  <nickc@redhat.com>
 
 	2.29.1 Release
diff --git a/opcodes/cr16-dis.c b/opcodes/cr16-dis.c
index 16385c35c9..4a3f3b7833 100644
--- a/opcodes/cr16-dis.c
+++ b/opcodes/cr16-dis.c
@@ -54,7 +54,7 @@ typedef struct
 cinv_entry;
 
 /* CR16 'cinv' options mapping.  */
-const cinv_entry cr16_cinvs[] =
+static const cinv_entry cr16_cinvs[] =
 {
   {"cinv[i]",     "cinv    [i]"},
   {"cinv[i,u]",   "cinv    [i,u]"},
@@ -78,20 +78,20 @@ typedef enum REG_ARG_TYPE
 REG_ARG_TYPE;
 
 /* Current opcode table entry we're disassembling.  */
-const inst *instruction;
+static const inst *instruction;
 /* Current instruction we're disassembling.  */
-ins cr16_currInsn;
+static ins cr16_currInsn;
 /* The current instruction is read into 3 consecutive words.  */
-wordU cr16_words[3];
+static wordU cr16_words[3];
 /* Contains all words in appropriate order.  */
-ULONGLONG cr16_allWords;
+static ULONGLONG cr16_allWords;
 /* Holds the current processed argument number.  */
-int processing_argument_number;
+static int processing_argument_number;
 /* Nonzero means a IMM4 instruction.  */
-int imm4flag;
+static int imm4flag;
 /* Nonzero means the instruction's original size is
    incremented (escape sequence is used).  */
-int size_changed;
+static int size_changed;
 
 
 /* Print the constant expression length.  */
diff --git a/opcodes/crx-dis.c b/opcodes/crx-dis.c
index 4e48668f68..cb0f08025b 100644
--- a/opcodes/crx-dis.c
+++ b/opcodes/crx-dis.c
@@ -58,7 +58,7 @@ typedef struct
 cinv_entry;
 
 /* CRX 'cinv' options.  */
-const cinv_entry crx_cinvs[] =
+static const cinv_entry crx_cinvs[] =
 {
   {"[i]", 2}, {"[i,u]", 3}, {"[d]", 4}, {"[d,u]", 5},
   {"[d,i]", 6}, {"[d,i,u]", 7}, {"[b]", 8},
@@ -81,22 +81,22 @@ typedef enum REG_ARG_TYPE
 REG_ARG_TYPE;
 
 /* Number of valid 'cinv' instruction options.  */
-int NUMCINVS = ((sizeof crx_cinvs)/(sizeof crx_cinvs[0]));
+static int NUMCINVS = ((sizeof crx_cinvs)/(sizeof crx_cinvs[0]));
 /* Current opcode table entry we're disassembling.  */
-const inst *instruction;
+static const inst *instruction;
 /* Current instruction we're disassembling.  */
-ins currInsn;
+static ins currInsn;
 /* The current instruction is read into 3 consecutive words.  */
-wordU words[3];
+static wordU words[3];
 /* Contains all words in appropriate order.  */
-ULONGLONG allWords;
+static ULONGLONG allWords;
 /* Holds the current processed argument number.  */
-int processing_argument_number;
+static int processing_argument_number;
 /* Nonzero means a CST4 instruction.  */
-int cst4flag;
+static int cst4flag;
 /* Nonzero means the instruction's original size is
    incremented (escape sequence is used).  */
-int size_changed;
+static int size_changed;
 
 static int get_number_of_operands (void);
 static argtype getargtype     (operand_type);
diff --git a/opcodes/crx-opc.c b/opcodes/crx-opc.c
index f6f2da669f..05b661da9d 100644
--- a/opcodes/crx-opc.c
+++ b/opcodes/crx-opc.c
@@ -704,15 +704,15 @@ The value in entry <N> is mapped to the value <N>
 Example (for N=5):
 
     cst4_map[5]=-4  -->>	5		*/
-const int cst4_map[] =
+const int crx_cst4_map[] =
 {
   0, 1, 2, 3, 4, -4, -1, 7, 8, 16, 32, 20, 12, 48
 };
 
-const int cst4_maps = ARRAY_SIZE (cst4_map);
+const int crx_cst4_maps = ARRAY_SIZE (crx_cst4_map);
 
 /* CRX instructions that don't have arguments.  */
-const char* no_op_insn[] =
+const char* crx_no_op_insn[] =
 {
   "di", "ei", "eiwait", "nop", "retx", "wait", NULL
 };
