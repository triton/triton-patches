diff --git a/bfd/ChangeLog b/bfd/ChangeLog
index c302aadf44..cd0a8f24d1 100644
--- a/bfd/ChangeLog
+++ b/bfd/ChangeLog
@@ -1,4 +1,50 @@
-2017-09-15  Nick Clifton  <nickc@redhat.com>
+2017-10-05  Alan Modra  <amodra@gmail.com>
+
+	* elflink.c (elf_link_input_bfd): Correct ctor/dtor in init_array/
+	fini_array error value.
+
+2017-10-04  Pavel I. Kryukov <kryukov@frtk.ru>
+
+	PR 22245
+	* bfd.c (bfd_set_error): Avoid UB on passing arg to va_start that
+	undergoes default promotion.
+	* bfd-in2.h: Regenerate.
+
+2017-09-28  Alan Modra  <amodra@gmail.com>
+
+	PR 22220
+	* elflink.c (_bfd_elf_merge_symbol): Set non_ir_ref_dynamic in
+	a case where plugin_notice isn't called.
+
+2017-09-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR ld/22199
+	* elf64-x86-64.c (elf_x86_64_finish_dynamic_symbol): Don't pass
+	output_bfd to info->callbacks->minfo.
+
+2017-09-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR binutils/22170
+	* elf32-i386.c (elf_i386_get_synthetic_symtab): Guard against
+	corrupted PLT.
+	* elf64-x86-64.c (elf_x86_64_get_synthetic_symtab): Likewise.
+
+2017-09-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR binutils/22163
+	* elf32-i386.c (elf_i386_get_synthetic_symtab): Also return -1
+	if bfd_canonicalize_dynamic_reloc returns 0.
+	* elf64-x86-64.c (elf_x86_64_get_synthetic_symtab): Likewise.
+
+2017-09-21  Nick Clifton  <nickc@redhat.com>
+
+	* development.sh (development): Revert previous delta.
+
+2017-09-20  Nick Clifton  <nickc@redhat.com>
+
+	* development.sh (development): Set to false.
+
+2017-09-19  Nick Clifton  <nickc@redhat.com>
 
 	2.29.1 Release
 
@@ -6,6 +52,56 @@
 	* configure: Regenerate.
 	* po/bfd.pot: Regenerate.
 
+2017-09-19  Nick Clifton  <nickc@redhat.com>
+
+	Import from mainline:
+
+	* xtensa-isa.c (xtensa_isa_init): Don't update lookup table
+	entries for sysregs with negative indices.
+
+2017-09-19  Alan Modra  <amodra@gmail.com>
+
+	PR 21441
+	* elf64-ppc.c (ppc64_elf_build_stubs): Don't check glink_eh_frame
+	size.
+
+2017-09-19  Alan Modra  <amodra@gmail.com>
+
+	PR 22150
+	* elflink.c (bfd_elf_size_dynamic_sections): Garbage collect
+	symbols before calculating verrefs.  Don't renumber dynsyms
+	after gc.  Exclude .gnu.version when zero or one dynsym.
+	Localize some vars and reindent.
+
+	Apply from master
+	2017-08-31  Alan Modra  <amodra@gmail.com>
+	* elf-eh-frame.c (_bfd_elf_parse_eh_frame): Don't exit early
+	for a section containing just a terminator.  Allow multiple
+	terminators at end of section.
+	* elflink.c (bfd_elf_discard_info): Iterate over .eh_frame
+	sections when not adding alignment.  Assert on terminator in
+	the middle of FDEs.
+
+	2017-08-31  Alan Modra  <amodra@gmail.com>
+	PR 21441
+	PR 22048
+	* elflink.c (bfd_elf_discard_info): Don't pad embedded zero
+	terminators.
+
+	2017-08-14  Alan Modra  <amodra@gmail.com>
+	PR 21441
+	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Don't add
+	alignment padding here.
+	* elflink.c (bfd_elf_discard_info): Add .eh_frame padding here
+	in a reverse pass over sections.
+
+2017-09-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR ld/22148
+	* elf32-i386.c (elf_i386_get_synthetic_symtab): Check error
+	return from bfd_canonicalize_dynamic_reloc.
+	* elf64-x86-64.c (elf_x86_64_get_synthetic_symtab): Likewise.
+
 2017-09-14  Nick Clifton  <nickc@redhat.com>
 
 	Import from mainline:
@@ -113,12 +209,6 @@
 	(elfcore_grok_freebsd_prstatus): Add checks to make sure that
 	there is enough data present in the note.
 
-	PR 21441
-	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Don't add
-	alignment padding here.
-	* elflink.c (bfd_elf_discard_info): Add .eh_frame padding here
-	in a reverse pass over sections.
-
 2017-09-04  Alan Modra  <amodra@gmail.com>
 
 	PR 22067
diff --git a/bfd/bfd-in2.h b/bfd/bfd-in2.h
index 1343780c8c..0dba68b1e6 100644
--- a/bfd/bfd-in2.h
+++ b/bfd/bfd-in2.h
@@ -7053,7 +7053,7 @@ bfd_error_type;
 
 bfd_error_type bfd_get_error (void);
 
-void bfd_set_error (bfd_error_type error_tag, ...);
+void bfd_set_error (int error_tag, ...);
 
 const char *bfd_errmsg (bfd_error_type error_tag);
 
diff --git a/bfd/bfd.c b/bfd/bfd.c
index 665f182559..5da1a6fd53 100644
--- a/bfd/bfd.c
+++ b/bfd/bfd.c
@@ -497,7 +497,7 @@ FUNCTION
 	bfd_set_error
 
 SYNOPSIS
-	void bfd_set_error (bfd_error_type error_tag, ...);
+	void bfd_set_error (int error_tag, ...);
 
 DESCRIPTION
 	Set the BFD error condition to be @var{error_tag}.
@@ -507,7 +507,7 @@ DESCRIPTION
 */
 
 void
-bfd_set_error (bfd_error_type error_tag, ...)
+bfd_set_error (int error_tag, ...)
 {
   bfd_error = error_tag;
   if (error_tag == bfd_error_on_input)
diff --git a/bfd/elf-eh-frame.c b/bfd/elf-eh-frame.c
index cd81b608d3..f0ede2d6f7 100644
--- a/bfd/elf-eh-frame.c
+++ b/bfd/elf-eh-frame.c
@@ -1335,7 +1335,7 @@ offset_adjust (bfd_vma offset, const asection *sec)
   struct eh_frame_sec_info *sec_info
     = (struct eh_frame_sec_info *) elf_section_data (sec)->sec_info;
   unsigned int lo, hi, mid;
-  struct eh_cie_fde *ent = NULL;
+  struct eh_cie_fde *ent;
   bfd_signed_vma delta;
 
   lo = 0;
diff --git a/bfd/elf32-i386.c b/bfd/elf32-i386.c
index 00a6397913..ba50c93f33 100644
--- a/bfd/elf32-i386.c
+++ b/bfd/elf32-i386.c
@@ -6342,6 +6342,8 @@ elf_i386_get_synthetic_symtab (bfd *abfd,
 
   dynrelcount = bfd_canonicalize_dynamic_reloc (abfd, dynrelbuf,
 						dynsyms);
+  if (dynrelcount <= 0)
+    return -1;
 
   /* Sort the relocs by address.  */
   qsort (dynrelbuf, dynrelcount, sizeof (arelent *), compare_relocs);
@@ -6614,6 +6616,10 @@ bad_return:
 		  size += sizeof ("+0x") - 1 + 8;
 		n++;
 		s++;
+		/* There should be only one entry in PLT for a given
+		   symbol.  Set howto to NULL after processing a PLT
+		   entry to guard against corrupted PLT.  */
+		p->howto = NULL;
 	      }
 	    offset += plt_entry_size;
 	  }
diff --git a/bfd/elf64-ppc.c b/bfd/elf64-ppc.c
index 3f01ae62a1..277bb0ef5d 100644
--- a/bfd/elf64-ppc.c
+++ b/bfd/elf64-ppc.c
@@ -13407,12 +13407,7 @@ ppc64_elf_build_stubs (struct bfd_link_info *info,
 	  break;
       }
 
-  /* Note that the glink_eh_frame check here is not only testing that
-     the generated size matched the calculated size but also that
-     bfd_elf_discard_info didn't make any changes to the section.  */
-  if (group != NULL
-      || (htab->glink_eh_frame != NULL
-	  && htab->glink_eh_frame->rawsize != htab->glink_eh_frame->size))
+  if (group != NULL)
     {
       htab->stub_error = TRUE;
       info->callbacks->einfo (_("%P: stubs don't match calculated size\n"));
diff --git a/bfd/elf64-x86-64.c b/bfd/elf64-x86-64.c
index 6bc1898a96..1f6dfb89bf 100644
--- a/bfd/elf64-x86-64.c
+++ b/bfd/elf64-x86-64.c
@@ -6133,7 +6133,6 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,
 	      if (SYMBOL_REFERENCES_LOCAL (info, h))
 		{
 		  info->callbacks->minfo (_("Local IFUNC function `%s' in %B\n"),
-					  output_bfd,
 					  h->root.root.string,
 					  h->root.u.def.section->owner);
 
@@ -6717,6 +6716,8 @@ elf_x86_64_get_synthetic_symtab (bfd *abfd,
 
   dynrelcount = bfd_canonicalize_dynamic_reloc (abfd, dynrelbuf,
 						dynsyms);
+  if (dynrelcount <= 0)
+    return -1;
 
   /* Sort the relocs by address.  */
   qsort (dynrelbuf, dynrelcount, sizeof (arelent *), compare_relocs);
@@ -6968,6 +6969,10 @@ bad_return:
 		  size += sizeof ("+0x") - 1 + 8 + 8 * ABI_64_P (abfd);
 		n++;
 		s++;
+		/* There should be only one entry in PLT for a given
+		   symbol.  Set howto to NULL after processing a PLT
+		   entry to guard against corrupted PLT.  */
+		p->howto = NULL;
 	      }
 	    offset += plt_entry_size;
 	  }
diff --git a/bfd/elflink.c b/bfd/elflink.c
index 301cf03436..39d878c814 100644
--- a/bfd/elflink.c
+++ b/bfd/elflink.c
@@ -1234,6 +1234,16 @@ _bfd_elf_merge_symbol (bfd *abfd,
       olddyn = (oldsec->symbol->flags & BSF_DYNAMIC) != 0;
     }
 
+  /* Handle a case where plugin_notice won't be called and thus won't
+     set the non_ir_ref flags on the first pass over symbols.  */
+  if (oldbfd != NULL
+      && (oldbfd->flags & BFD_PLUGIN) != (abfd->flags & BFD_PLUGIN)
+      && newdyn != olddyn)
+    {
+      h->root.non_ir_ref_dynamic = TRUE;
+      hi->root.non_ir_ref_dynamic = TRUE;
+    }
+
   /* NEWDEF and OLDDEF indicate whether the new or old symbol,
      respectively, appear to be a definition rather than reference.  */
 
@@ -6000,19 +6010,18 @@ bfd_elf_size_dynamic_sections (bfd *output_bfd,
       struct elf_info_failed asvinfo;
       struct bfd_elf_version_tree *t;
       struct bfd_elf_version_expr *d;
-      struct elf_info_failed eif;
-      bfd_boolean all_defined;
       asection *s;
       size_t soname_indx;
 
-      eif.info = info;
-      eif.failed = FALSE;
-
       /* If we are supposed to export all symbols into the dynamic symbol
 	 table (this is not the normal case), then do so.  */
       if (info->export_dynamic
 	  || (bfd_link_executable (info) && info->dynamic))
 	{
+	  struct elf_info_failed eif;
+
+	  eif.info = info;
+	  eif.failed = FALSE;
 	  elf_link_hash_traverse (elf_hash_table (info),
 				  _bfd_elf_export_symbol,
 				  &eif);
@@ -6096,7 +6105,7 @@ bfd_elf_size_dynamic_sections (bfd *output_bfd,
       if (!info->allow_undefined_version)
 	{
 	  /* Check if all global versions have a definition.  */
-	  all_defined = TRUE;
+	  bfd_boolean all_defined = TRUE;
 	  for (t = info->version_info; t != NULL; t = t->next)
 	    for (d = t->globals.list; d != NULL; d = d->next)
 	      if (d->literal && !d->symver && !d->script)
@@ -6349,134 +6358,128 @@ bfd_elf_size_dynamic_sections (bfd *output_bfd,
 
 	  elf_tdata (output_bfd)->cverdefs = cdefs;
 	}
+    }
+
+  bed = get_elf_backend_data (output_bfd);
+
+  if (info->gc_sections && bed->can_gc_sections)
+    {
+      struct elf_gc_sweep_symbol_info sweep_info;
+
+      /* Remove the symbols that were in the swept sections from the
+	 dynamic symbol table.  */
+      sweep_info.info = info;
+      sweep_info.hide_symbol = bed->elf_backend_hide_symbol;
+      elf_link_hash_traverse (elf_hash_table (info), elf_gc_sweep_symbol,
+			      &sweep_info);
+    }
+
+  if (dynobj != NULL && elf_hash_table (info)->dynamic_sections_created)
+    {
+      asection *s;
+      struct elf_find_verdep_info sinfo;
 
       /* Work out the size of the version reference section.  */
 
       s = bfd_get_linker_section (dynobj, ".gnu.version_r");
       BFD_ASSERT (s != NULL);
-      {
-	struct elf_find_verdep_info sinfo;
 
-	sinfo.info = info;
-	sinfo.vers = elf_tdata (output_bfd)->cverdefs;
-	if (sinfo.vers == 0)
-	  sinfo.vers = 1;
-	sinfo.failed = FALSE;
+      sinfo.info = info;
+      sinfo.vers = elf_tdata (output_bfd)->cverdefs;
+      if (sinfo.vers == 0)
+	sinfo.vers = 1;
+      sinfo.failed = FALSE;
 
-	elf_link_hash_traverse (elf_hash_table (info),
-				_bfd_elf_link_find_version_dependencies,
-				&sinfo);
-	if (sinfo.failed)
-	  return FALSE;
-
-	if (elf_tdata (output_bfd)->verref == NULL)
-	  s->flags |= SEC_EXCLUDE;
-	else
-	  {
-	    Elf_Internal_Verneed *vn;
-	    unsigned int size;
-	    unsigned int crefs;
-	    bfd_byte *p;
-
-	    /* Build the version dependency section.  */
-	    size = 0;
-	    crefs = 0;
-	    for (vn = elf_tdata (output_bfd)->verref;
-		 vn != NULL;
-		 vn = vn->vn_nextref)
-	      {
-		Elf_Internal_Vernaux *a;
+      elf_link_hash_traverse (elf_hash_table (info),
+			      _bfd_elf_link_find_version_dependencies,
+			      &sinfo);
+      if (sinfo.failed)
+	return FALSE;
 
-		size += sizeof (Elf_External_Verneed);
-		++crefs;
-		for (a = vn->vn_auxptr; a != NULL; a = a->vna_nextptr)
-		  size += sizeof (Elf_External_Vernaux);
-	      }
+      if (elf_tdata (output_bfd)->verref == NULL)
+	s->flags |= SEC_EXCLUDE;
+      else
+	{
+	  Elf_Internal_Verneed *vn;
+	  unsigned int size;
+	  unsigned int crefs;
+	  bfd_byte *p;
 
-	    s->size = size;
-	    s->contents = (unsigned char *) bfd_alloc (output_bfd, s->size);
-	    if (s->contents == NULL)
-	      return FALSE;
+	  /* Build the version dependency section.  */
+	  size = 0;
+	  crefs = 0;
+	  for (vn = elf_tdata (output_bfd)->verref;
+	       vn != NULL;
+	       vn = vn->vn_nextref)
+	    {
+	      Elf_Internal_Vernaux *a;
 
-	    p = s->contents;
-	    for (vn = elf_tdata (output_bfd)->verref;
-		 vn != NULL;
-		 vn = vn->vn_nextref)
-	      {
-		unsigned int caux;
-		Elf_Internal_Vernaux *a;
-		size_t indx;
-
-		caux = 0;
-		for (a = vn->vn_auxptr; a != NULL; a = a->vna_nextptr)
-		  ++caux;
-
-		vn->vn_version = VER_NEED_CURRENT;
-		vn->vn_cnt = caux;
-		indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
-					    elf_dt_name (vn->vn_bfd) != NULL
-					    ? elf_dt_name (vn->vn_bfd)
-					    : lbasename (vn->vn_bfd->filename),
-					    FALSE);
-		if (indx == (size_t) -1)
-		  return FALSE;
-		vn->vn_file = indx;
-		vn->vn_aux = sizeof (Elf_External_Verneed);
-		if (vn->vn_nextref == NULL)
-		  vn->vn_next = 0;
-		else
-		  vn->vn_next = (sizeof (Elf_External_Verneed)
-				+ caux * sizeof (Elf_External_Vernaux));
+	      size += sizeof (Elf_External_Verneed);
+	      ++crefs;
+	      for (a = vn->vn_auxptr; a != NULL; a = a->vna_nextptr)
+		size += sizeof (Elf_External_Vernaux);
+	    }
 
-		_bfd_elf_swap_verneed_out (output_bfd, vn,
-					   (Elf_External_Verneed *) p);
-		p += sizeof (Elf_External_Verneed);
+	  s->size = size;
+	  s->contents = (unsigned char *) bfd_alloc (output_bfd, s->size);
+	  if (s->contents == NULL)
+	    return FALSE;
 
-		for (a = vn->vn_auxptr; a != NULL; a = a->vna_nextptr)
-		  {
-		    a->vna_hash = bfd_elf_hash (a->vna_nodename);
-		    indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
-						a->vna_nodename, FALSE);
-		    if (indx == (size_t) -1)
-		      return FALSE;
-		    a->vna_name = indx;
-		    if (a->vna_nextptr == NULL)
-		      a->vna_next = 0;
-		    else
-		      a->vna_next = sizeof (Elf_External_Vernaux);
+	  p = s->contents;
+	  for (vn = elf_tdata (output_bfd)->verref;
+	       vn != NULL;
+	       vn = vn->vn_nextref)
+	    {
+	      unsigned int caux;
+	      Elf_Internal_Vernaux *a;
+	      size_t indx;
 
-		    _bfd_elf_swap_vernaux_out (output_bfd, a,
-					       (Elf_External_Vernaux *) p);
-		    p += sizeof (Elf_External_Vernaux);
-		  }
-	      }
+	      caux = 0;
+	      for (a = vn->vn_auxptr; a != NULL; a = a->vna_nextptr)
+		++caux;
 
-	    elf_tdata (output_bfd)->cverrefs = crefs;
-	  }
-      }
-    }
+	      vn->vn_version = VER_NEED_CURRENT;
+	      vn->vn_cnt = caux;
+	      indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
+					  elf_dt_name (vn->vn_bfd) != NULL
+					  ? elf_dt_name (vn->vn_bfd)
+					  : lbasename (vn->vn_bfd->filename),
+					  FALSE);
+	      if (indx == (size_t) -1)
+		return FALSE;
+	      vn->vn_file = indx;
+	      vn->vn_aux = sizeof (Elf_External_Verneed);
+	      if (vn->vn_nextref == NULL)
+		vn->vn_next = 0;
+	      else
+		vn->vn_next = (sizeof (Elf_External_Verneed)
+			       + caux * sizeof (Elf_External_Vernaux));
 
-  bed = get_elf_backend_data (output_bfd);
+	      _bfd_elf_swap_verneed_out (output_bfd, vn,
+					 (Elf_External_Verneed *) p);
+	      p += sizeof (Elf_External_Verneed);
 
-  if (info->gc_sections && bed->can_gc_sections)
-    {
-      struct elf_gc_sweep_symbol_info sweep_info;
-      unsigned long section_sym_count;
+	      for (a = vn->vn_auxptr; a != NULL; a = a->vna_nextptr)
+		{
+		  a->vna_hash = bfd_elf_hash (a->vna_nodename);
+		  indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
+					      a->vna_nodename, FALSE);
+		  if (indx == (size_t) -1)
+		    return FALSE;
+		  a->vna_name = indx;
+		  if (a->vna_nextptr == NULL)
+		    a->vna_next = 0;
+		  else
+		    a->vna_next = sizeof (Elf_External_Vernaux);
 
-      /* Remove the symbols that were in the swept sections from the
-	 dynamic symbol table.  GCFIXME: Anyone know how to get them
-	 out of the static symbol table as well?  */
-      sweep_info.info = info;
-      sweep_info.hide_symbol = bed->elf_backend_hide_symbol;
-      elf_link_hash_traverse (elf_hash_table (info), elf_gc_sweep_symbol,
-			      &sweep_info);
+		  _bfd_elf_swap_vernaux_out (output_bfd, a,
+					     (Elf_External_Vernaux *) p);
+		  p += sizeof (Elf_External_Vernaux);
+		}
+	    }
 
-      /* We need to reassign dynsym indices now that symbols may have
-	 been removed.  See the call in `bfd_elf_size_dynsym_hash_dynstr'
-	 for the details of the conditions used here.  */
-      if (elf_hash_table (info)->dynamic_sections_created
-	  || bed->always_renumber_dynsyms)
-	_bfd_elf_link_renumber_dynsyms (output_bfd, info, &section_sym_count);
+	  elf_tdata (output_bfd)->cverrefs = crefs;
+	}
     }
 
   /* Any syms created from now on start with -1 in
@@ -6786,7 +6789,7 @@ bfd_elf_size_dynamic_sections (bfd *output_bfd,
       if ((elf_tdata (output_bfd)->cverrefs == 0
 	   && elf_tdata (output_bfd)->cverdefs == 0)
 	  || _bfd_elf_link_renumber_dynsyms (output_bfd, info,
-					     &section_sym_count) == 0)
+					     &section_sym_count) <= 1)
 	{
 	  asection *s;
 
@@ -10436,7 +10439,7 @@ elf_link_input_bfd (struct elf_final_link_info *flinfo, bfd *input_bfd)
 		    (_("error: %B: size of section %A is not "
 		       "multiple of address size"),
 		     input_bfd, o);
-		  bfd_set_error (bfd_error_on_input);
+		  bfd_set_error (bfd_error_bad_value);
 		  return FALSE;
 		}
 	      o->flags |= SEC_ELF_REVERSE_COPY;
@@ -13887,7 +13890,6 @@ bfd_elf_discard_info (bfd *output_bfd, struct bfd_link_info *info)
 		eh_changed = 1;
 	      }
 	  }
-
       if (eh_changed)
 	elf_link_hash_traverse (elf_hash_table (info),
 				_bfd_elf_adjust_eh_frame_global_symbol, NULL);
diff --git a/bfd/version.h b/bfd/version.h
index f7c691669a..ab58d2302e 100644
--- a/bfd/version.h
+++ b/bfd/version.h
@@ -1,4 +1,4 @@
-#define BFD_VERSION_DATE 20170915
+#define BFD_VERSION_DATE 20171026
 #define BFD_VERSION @bfd_version@
 #define BFD_VERSION_STRING  @bfd_version_package@ @bfd_version_string@
 #define REPORT_BUGS_TO @report_bugs_to@
diff --git a/bfd/xtensa-isa.c b/bfd/xtensa-isa.c
index 8da75bea81..5656062646 100644
--- a/bfd/xtensa-isa.c
+++ b/bfd/xtensa-isa.c
@@ -292,7 +292,8 @@ xtensa_isa_init (xtensa_isa_status *errno_p, char **error_msg_p)
       xtensa_sysreg_internal *sreg = &isa->sysregs[n];
       is_user = sreg->is_user;
 
-      isa->sysreg_table[is_user][sreg->number] = n;
+      if (sreg->number >= 0)
+	isa->sysreg_table[is_user][sreg->number] = n;
     }
 
   /* Set up the interface lookup table.  */
@@ -1790,4 +1791,3 @@ xtensa_funcUnit_num_copies (xtensa_isa isa, xtensa_funcUnit fun)
   CHECK_FUNCUNIT (intisa, fun, XTENSA_UNDEFINED);
   return intisa->funcUnits[fun].num_copies;
 }
-
diff --git a/binutils/ChangeLog b/binutils/ChangeLog
index 84d3d7c1c4..ffb34fbb78 100644
--- a/binutils/ChangeLog
+++ b/binutils/ChangeLog
@@ -1,3 +1,7 @@
+2017-09-21  Maciej W. Rozycki  <macro@imgtec.com>
+
+	* readelf.c (get_machine_flags) <E_MIPS_MACH_5900>: New case.
+
 2017-09-15  Nick Clifton  <nickc@redhat.com>
 
 	2.29.1 Release
diff --git a/binutils/readelf.c b/binutils/readelf.c
index fb16df8e2a..41f128ed23 100644
--- a/binutils/readelf.c
+++ b/binutils/readelf.c
@@ -3325,6 +3325,7 @@ get_machine_flags (unsigned e_flags, unsigned e_machine)
 	    case E_MIPS_MACH_4650: strcat (buf, ", 4650"); break;
 	    case E_MIPS_MACH_5400: strcat (buf, ", 5400"); break;
 	    case E_MIPS_MACH_5500: strcat (buf, ", 5500"); break;
+	    case E_MIPS_MACH_5900: strcat (buf, ", 5900"); break;
 	    case E_MIPS_MACH_SB1:  strcat (buf, ", sb1");  break;
 	    case E_MIPS_MACH_9000: strcat (buf, ", 9000"); break;
   	    case E_MIPS_MACH_LS2E: strcat (buf, ", loongson-2e"); break;
diff --git a/gas/ChangeLog b/gas/ChangeLog
index 42a676f598..9aa3dbca3a 100644
--- a/gas/ChangeLog
+++ b/gas/ChangeLog
@@ -1,3 +1,8 @@
+2017-09-21  Maciej W. Rozycki  <macro@imgtec.com>
+
+	* testsuite/gas/mips/elf_mach_5900.d: New test.
+	* testsuite/gas/mips/mips.exp: Run it.
+
 2017-09-15  Nick Clifton  <nickc@redhat.com>
 
 	2.29.1 Release
diff --git a/gas/testsuite/gas/mips/elf_mach_5900.d b/gas/testsuite/gas/mips/elf_mach_5900.d
new file mode 100644
index 0000000000..1df668e7e5
--- /dev/null
+++ b/gas/testsuite/gas/mips/elf_mach_5900.d
@@ -0,0 +1,22 @@
+#readelf: -Ah
+#name: ELF R5900 markings
+#as: -32 -march=r5900
+#source: empty.s
+
+ELF Header:
+#...
+  Flags: +0x..92...., .*5900.*
+#...
+
+MIPS ABI Flags Version: 0
+
+ISA: MIPS3
+GPR size: 32
+CPR1 size: 32
+CPR2 size: 0
+FP ABI: .*
+ISA Extension: Toshiba R5900
+ASEs:
+	None
+FLAGS 1: .*
+FLAGS 2: .*
diff --git a/gas/testsuite/gas/mips/mips.exp b/gas/testsuite/gas/mips/mips.exp
index c71dca4351..25221ae2af 100644
--- a/gas/testsuite/gas/mips/mips.exp
+++ b/gas/testsuite/gas/mips/mips.exp
@@ -1149,6 +1149,7 @@ if { [istarget mips*-*-vxworks*] } {
     run_dump_test "elf_ase_micromips-2"
 
     # Verify that machine markings are handled properly.
+    run_dump_test "elf_mach_5900"
     run_dump_test "elf_mach_interaptiv-mr2"
 
     run_dump_test "mips-gp32-fp32-pic"
diff --git a/gold/ChangeLog b/gold/ChangeLog
index cee2289a23..622a63a214 100644
--- a/gold/ChangeLog
+++ b/gold/ChangeLog
@@ -1,3 +1,31 @@
+2017-10-18  Kyle Butt  <iteratee@google.com>
+	    Alan Modra  <amodra@gmail.com>
+
+	* powerpc.cc (Target_powerpc::Scan::local): Correct dst_off
+	calculation for TOC16 relocs.
+	(Target_powerpc::Scan::global): Likewise.
+
+2017-09-28  Alan Modra  <amodra@gmail.com>
+
+	* powerpc.cc (Target_powerpc<64,*>::powerpc_info): Set
+	is_default_stack_executable false.
+
+2017-08-03  James Clarke  <jrtc27@jrtc27.com>
+
+	* options.h (General_options): Set a non-NULL second help string
+	argument for relax to allow --no-relax.
+
+2017-09-20  Alan Modra  <amodra@gmail.com>
+
+	* powerpc.cc (Target_powerpc::Branch_info::make_stub): Put
+	stubs for ppc32 non-branch relocs in first stub table.
+	(Target_powerpc::Relocate::relocate): Resolve similarly.
+
+2017-09-19  Alan Modra  <amodra@gmail.com>
+
+	* options.h (stub-group-multi): Default to true.  Add
+	--no-stub-group-multi.
+
 2017-09-15  Nick Clifton  <nickc@redhat.com>
 
 	2.29.1 Release
diff --git a/gold/options.h b/gold/options.h
index c7c032bbd7..4a802cf41f 100644
--- a/gold/options.h
+++ b/gold/options.h
@@ -1164,7 +1164,8 @@ class General_options
 	      N_("Generate relocatable output"), NULL);
 
   DEFINE_bool(relax, options::TWO_DASHES, '\0', false,
-	      N_("Relax branches on certain targets"), NULL);
+	      N_("Relax branches on certain targets"),
+	      N_("Do not relax branches"));
 
   DEFINE_string(retain_symbols_file, options::TWO_DASHES, '\0', NULL,
 		N_("keep only symbols listed in this file"), N_("FILE"));
@@ -1234,9 +1235,10 @@ class General_options
 		"stubs are always after the group. 1 means use default size"),
 	     N_("SIZE"));
 
-  DEFINE_bool(stub_group_multi, options::TWO_DASHES, '\0', false,
+  DEFINE_bool(stub_group_multi, options::TWO_DASHES, '\0', true,
 	      N_("(PowerPC only) Allow a group of stubs to serve multiple "
-		 "output sections"), NULL);
+		 "output sections"),
+	      N_("(PowerPC only) Each output section has its own stubs"));
 
   DEFINE_uint(split_stack_adjust_size, options::TWO_DASHES, '\0', 0x4000,
 	      N_("Stack size when -fsplit-stack function calls non-split"),
diff --git a/gold/powerpc.cc b/gold/powerpc.cc
index 629da4f8a1..b5db66549e 100644
--- a/gold/powerpc.cc
+++ b/gold/powerpc.cc
@@ -1618,7 +1618,7 @@ Target::Target_info Target_powerpc<64, true>::powerpc_info =
   false,		// has_make_symbol
   true,			// has_resolve
   false,		// has_code_fill
-  true,			// is_default_stack_executable
+  false,		// is_default_stack_executable
   false,		// can_icf_inline_merge_sections
   '\0',			// wrap_char
   "/usr/lib/ld.so.1",	// dynamic_linker
@@ -1646,7 +1646,7 @@ Target::Target_info Target_powerpc<64, false>::powerpc_info =
   false,		// has_make_symbol
   true,			// has_resolve
   false,		// has_code_fill
-  true,			// is_default_stack_executable
+  false,		// is_default_stack_executable
   false,		// can_icf_inline_merge_sections
   '\0',			// wrap_char
   "/usr/lib/ld.so.1",	// dynamic_linker
@@ -3065,11 +3065,17 @@ Target_powerpc<size, big_endian>::Branch_info::make_stub(
 	target->glink_section()->add_global_entry(gsym);
       else
 	{
-	  if (stub_table == NULL)
+	  if (stub_table == NULL
+	      && !(size == 32
+		   && gsym != NULL
+		   && !parameters->options().output_is_position_independent()
+		   && !is_branch_reloc(this->r_type_)))
 	    stub_table = this->object_->stub_table(this->shndx_);
 	  if (stub_table == NULL)
 	    {
-	      // This is a ref from a data section to an ifunc symbol.
+	      // This is a ref from a data section to an ifunc symbol,
+	      // or a non-branch reloc for which we always want to use
+	      // one set of stubs for resolving function addresses.
 	      stub_table = ifunc_stub_table;
 	    }
 	  gold_assert(stub_table != NULL);
@@ -6643,7 +6649,7 @@ Target_powerpc<size, big_endian>::Scan::local(
 	  shndx = ppc_object->adjust_sym_shndx(r_sym, shndx, &is_ordinary);
 	  if (is_ordinary && shndx == ppc_object->toc_shndx())
 	    {
-	      Address dst_off = lsym.get_st_value() + reloc.get_r_offset();
+	      Address dst_off = lsym.get_st_value() + reloc.get_r_addend();
 	      if (dst_off < ppc_object->section_size(shndx))
 		{
 		  bool ok = false;
@@ -7311,7 +7317,7 @@ Target_powerpc<size, big_endian>::Scan::global(
 	      if (shndx == sym_object->toc_shndx())
 		{
 		  Sized_symbol<size>* sym = symtab->get_sized_symbol<size>(gsym);
-		  Address dst_off = sym->value() + reloc.get_r_offset();
+		  Address dst_off = sym->value() + reloc.get_r_addend();
 		  if (dst_off < sym_object->section_size(shndx))
 		    {
 		      bool ok = false;
@@ -8052,11 +8058,20 @@ Target_powerpc<size, big_endian>::Relocate::relocate(
 	}
       else
 	{
-	  Stub_table<size, big_endian>* stub_table
-	    = object->stub_table(relinfo->data_shndx);
+	  Stub_table<size, big_endian>* stub_table = NULL;
+	  if (target->stub_tables().size() == 1)
+	    stub_table = target->stub_tables()[0];
+	  if (stub_table == NULL
+	      && !(size == 32
+		   && gsym != NULL
+		   && !parameters->options().output_is_position_independent()
+		   && !is_branch_reloc(r_type)))
+	    stub_table = object->stub_table(relinfo->data_shndx);
 	  if (stub_table == NULL)
 	    {
-	      // This is a ref from a data section to an ifunc symbol.
+	      // This is a ref from a data section to an ifunc symbol,
+	      // or a non-branch reloc for which we always want to use
+	      // one set of stubs for resolving function addresses.
 	      if (target->stub_tables().size() != 0)
 		stub_table = target->stub_tables()[0];
 	    }
diff --git a/ld/ChangeLog b/ld/ChangeLog
index 406e72c112..ba67e20bf9 100644
--- a/ld/ChangeLog
+++ b/ld/ChangeLog
@@ -1,10 +1,44 @@
-2017-09-15  Nick Clifton  <nickc@redhat.com>
+2017-09-28  Alan Modra  <amodra@gmail.com>
+
+	* testsuite/ld-plugin/pr22220.h,
+	* testsuite/ld-plugin/pr22220lib.cc,
+	* testsuite/ld-plugin/pr22220lib.ver,
+	* testsuite/ld-plugin/pr22220main.cc: New test.
+	* testsuite/ld-plugin/lto.exp: Run it.
+
+2017-09-19  Nick Clifton  <nickc@redhat.com>
 
 	2.29.1 Release
 
 	* configure: Regenerate.
 	* po/ld.pot: Regenerate.
 
+2017-09-19  Nick Clifton  <nickc@redhat.com>
+
+	Import from mainline:
+
+	* emultempl/xtensaelf.em (xtensa_wild_group_interleave_callback):
+	Only check for by_name sorting.
+
+2017-08-31  Alan Modra  <amodra@gmail.com>
+
+	* testsuite/ld-elf/eh3.d: Update.
+	* testsuite/ld-elf/eh4.d: Update.
+
+2017-08-14  Alan Modra  <amodra@gmail.com>
+
+	PR 21441
+	* testsuite/ld-x86-64/pr21038a.d: Adjust.
+	* testsuite/ld-x86-64/pr21038a-now.d: Adjust.
+
+2017-09-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR ld/21924
+	* testsuite/ld-i386/i386.exp: Require GCC 5 or above for
+	"weakundef1 with PIE" test.
+	* testsuite/ld-x86-64/tls.exp: Require GCC 5 or above for
+	"tlsdesc1" and "tlsdesc1 with PIE" tests.
+
 2017-08-21  Hans-Peter Nilsson  <hp@bitrange.com>
 
 	Import from mainline:
@@ -22,17 +56,6 @@
 	* testsuite/ld-powerpc/relbrlt.d: Pass --no-plt-align.
 	* testsuite/ld-powerpc/elfv2so.d: Adjust expected output.
 
-2017-09-04  Nick Clifton  <nickc@redhat.com>
-
-	Import from mainline:
-
-	* testsuite/ld-elf/eh3.d: Update.
-	* testsuite/ld-elf/eh4.d: Update.
-
-	PR 21441
-	* testsuite/ld-x86-64/pr21038a.d: Adjust.
-	* testsuite/ld-x86-64/pr21038a-now.d: Adjust.
-
 2017-09-01  H.J. Lu  <hongjiu.lu@intel.com>
 
 	PR ld/22064
diff --git a/ld/emultempl/xtensaelf.em b/ld/emultempl/xtensaelf.em
index 1447d526a2..3827d91b62 100644
--- a/ld/emultempl/xtensaelf.em
+++ b/ld/emultempl/xtensaelf.em
@@ -1432,7 +1432,7 @@ xtensa_wild_group_interleave_callback (lang_statement_union_type *statement)
 	  struct wildcard_list *l;
 	  for (l = w->section_list; l != NULL; l = l->next)
 	    {
-	      if (l->spec.sorted != none)
+	      if (l->spec.sorted == by_name)
 		{
 		  no_reorder = TRUE;
 		  break;
diff --git a/ld/testsuite/ld-i386/i386.exp b/ld/testsuite/ld-i386/i386.exp
index 1734d67a37..1a35a572b2 100644
--- a/ld/testsuite/ld-i386/i386.exp
+++ b/ld/testsuite/ld-i386/i386.exp
@@ -1251,16 +1251,20 @@ if { [isnative]
 	    "pass.out" \
 	    "$NOPIE_CFLAGS" \
 	] \
-	[list \
-	    "Run weakundef1 with PIE" \
-	    "-pie" \
-	    "" \
-	    { weakundef1.c } \
-	    "weakundef1pie" \
-	    "pass.out" \
-	    "-fPIE" \
-	] \
     ]
+    if { [at_least_gcc_version 5 0] } {
+	run_ld_link_exec_tests [list \
+	    [list \
+		"Run weakundef1 with PIE" \
+		"-pie" \
+		"" \
+		{ weakundef1.c } \
+		"weakundef1pie" \
+		"pass.out" \
+		"-fPIE" \
+	    ] \
+	]
+    }
 }
 
 if { !([istarget "i?86-*-linux*"]
diff --git a/ld/testsuite/ld-plugin/lto.exp b/ld/testsuite/ld-plugin/lto.exp
index f0bc345f2c..6b7ad536fb 100644
--- a/ld/testsuite/ld-plugin/lto.exp
+++ b/ld/testsuite/ld-plugin/lto.exp
@@ -295,6 +295,12 @@ set lto_link_elf_tests [list \
   [list "Build pr21382.so" \
    "-shared" "-O2 -fpic" \
    {pr21382b.c} {} "pr21382.so" "c"] \
+  [list {Build pr22220lib.so} \
+   {-shared -Wl,--version-script=pr22220lib.ver} {-fPIC} \
+   {pr22220lib.cc} {} {pr22220lib.so} {c++}] \
+  [list {Build pr22220main.o} \
+   {} {-flto} \
+   {pr22220main.cc} {} {} {c++}] \
 ]
 
 # Check final symbols in executables.
@@ -396,6 +402,12 @@ set lto_run_elf_shared_tests [list \
   [list "Run pr21382" \
    "-O2 -flto -fuse-linker-plugin -Wl,--as-needed tmpdir/pr21382a.o tmpdir/pr21382.so" "" \
    {dummy.c} "pr21382.exe" "pass.out" "" "c"] \
+  [list {pr22220a} \
+   {-flto -fuse-linker-plugin tmpdir/pr22220main.o tmpdir/pr22220lib.so} {} \
+   {dummy.c} {pr22220a.exe} {pass.out} {} {c++}] \
+  [list {pr22220b} \
+   {-flto -fuse-linker-plugin -Wl,--no-as-needed tmpdir/pr22220lib.so tmpdir/pr22220main.o} {} \
+   {dummy.c} {pr22220b.exe} {pass.out} {} {c++}] \
 ]
 
 # LTO run-time tests for ELF
diff --git a/ld/testsuite/ld-plugin/pr22220.h b/ld/testsuite/ld-plugin/pr22220.h
new file mode 100644
index 0000000000..b15b45c08d
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr22220.h
@@ -0,0 +1,8 @@
+extern int doo();
+
+inline int *goo() {
+	static int xyz;
+	return &xyz;
+}
+
+int *boo();
diff --git a/ld/testsuite/ld-plugin/pr22220lib.cc b/ld/testsuite/ld-plugin/pr22220lib.cc
new file mode 100644
index 0000000000..771f44f7f3
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr22220lib.cc
@@ -0,0 +1,6 @@
+#include "pr22220.h"
+
+int* boo()
+{
+  return goo ();
+}
diff --git a/ld/testsuite/ld-plugin/pr22220lib.ver b/ld/testsuite/ld-plugin/pr22220lib.ver
new file mode 100644
index 0000000000..6da7e1a2bd
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr22220lib.ver
@@ -0,0 +1 @@
+BAR { global: *; };
diff --git a/ld/testsuite/ld-plugin/pr22220main.cc b/ld/testsuite/ld-plugin/pr22220main.cc
new file mode 100644
index 0000000000..38c206f7a2
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr22220main.cc
@@ -0,0 +1,12 @@
+#include <stdio.h>
+#include "pr22220.h"
+
+int main()
+{
+  if (boo() == goo())
+    {
+      printf ("PASS\n");
+      return 0;
+    }
+  return 1;
+}
diff --git a/ld/testsuite/ld-x86-64/pr21038a-now.d b/ld/testsuite/ld-x86-64/pr21038a-now.d
index 1d5bec1854..6948ded162 100644
--- a/ld/testsuite/ld-x86-64/pr21038a-now.d
+++ b/ld/testsuite/ld-x86-64/pr21038a-now.d
@@ -1,7 +1,7 @@
 #name: PR ld/21038 (.plt.got, -z now)
 #source: pr21038a.s
 #as: --64
-#ld: -z now -z bndplt -melf_x86_64 -shared -z relro --ld-generated-unwind-info --hash-style=sysv
+#ld: -z now -z bndplt -melf_x86_64 -shared -z relro --ld-generated-unwind-info
 #objdump: -dw -Wf
 
 .*: +file format .*
diff --git a/ld/testsuite/ld-x86-64/pr21038a.d b/ld/testsuite/ld-x86-64/pr21038a.d
index 01770ec671..7b1b7dcd4c 100644
--- a/ld/testsuite/ld-x86-64/pr21038a.d
+++ b/ld/testsuite/ld-x86-64/pr21038a.d
@@ -1,6 +1,6 @@
 #name: PR ld/21038 (.plt.got)
 #as: --64
-#ld: -z bndplt -melf_x86_64 -shared -z relro --ld-generated-unwind-info --hash-style=sysv
+#ld: -z bndplt -melf_x86_64 -shared -z relro --ld-generated-unwind-info
 #objdump: -dw -Wf
 
 .*: +file format .*
diff --git a/ld/testsuite/ld-x86-64/tls.exp b/ld/testsuite/ld-x86-64/tls.exp
index 4263d95bd1..7896451c01 100644
--- a/ld/testsuite/ld-x86-64/tls.exp
+++ b/ld/testsuite/ld-x86-64/tls.exp
@@ -206,16 +206,30 @@ if { ![check_gnu2_tls_available] } {
     return
 }
 
+if { [at_least_gcc_version 5 0] } {
+    run_ld_link_exec_tests [list \
+	[list \
+	    "Run tlsdesc1" \
+	    "-Wl,--no-as-needed tmpdir/libtlsdesc1.so" \
+	    "" \
+	    { tlsdesc1a.c } \
+	    "tlsdesc1a" \
+	    "pass.out" \
+	    "$GNU2_CFLAGS" \
+	] \
+	[list \
+	    "Run tlsdesc1 with PIE" \
+	    "-pie -Wl,--no-as-needed tmpdir/libtlsdesc1.so" \
+	    "" \
+	    { tlsdesc1a.c } \
+	    "tlsdesc1c" \
+	    "pass.out" \
+	    "-fPIE $GNU2_CFLAGS" \
+	] \
+    ]
+}
+
 run_ld_link_exec_tests [list \
-    [list \
-	"Run tlsdesc1" \
-	"-Wl,--no-as-needed tmpdir/libtlsdesc1.so" \
-	"" \
-	{ tlsdesc1a.c } \
-	"tlsdesc1a" \
-	"pass.out" \
-	"$GNU2_CFLAGS" \
-    ] \
     [list \
 	"Run tlsdesc1 (-z now)" \
 	"-Wl,-z,now -Wl,--no-as-needed tmpdir/libtlsdesc1n.so" \
@@ -225,15 +239,6 @@ run_ld_link_exec_tests [list \
 	"pass.out" \
 	"$GNU2_CFLAGS" \
     ] \
-    [list \
-	"Run tlsdesc1 with PIE" \
-	"-pie -Wl,--no-as-needed tmpdir/libtlsdesc1.so" \
-	"" \
-	{ tlsdesc1a.c } \
-	"tlsdesc1c" \
-	"pass.out" \
-	"-fPIE $GNU2_CFLAGS" \
-    ] \
     [list \
 	"Run tlsdesc1 with PIE (-z now)" \
 	"-pie -Wl,-z,now -Wl,--no-as-needed tmpdir/libtlsdesc1n.so" \
