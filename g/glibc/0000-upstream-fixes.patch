diff --git a/ChangeLog b/ChangeLog
index 8dbfc7eaff..84721f6265 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,262 @@
+2017-09-11  H.J. Lu  <hongjiu.lu@intel.com>
+
+	[BZ #21982]
+	* string/stratcliff.c (do_test): Declare size, nchars, inner,
+	middle and outer with size_t instead of int.  Repleace %d and
+	%Zd with %zu in printf.  Update "MAX (0, nchars - 128)" and
+	"MAX (outer, nchars - 64)" to support unsigned outer and
+	nchars.  Also exit loop when outer == 0.
+
+2017-09-08  Markus Trippelsdorf  <markus@trippelsdorf.de>
+
+	* sysdeps/x86_64/fpu/libm-test-ulps: Update for AMD Ryzen.
+
+2017-09-07  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* resolv/tst-resolv-qtypes.c (domain): Changed to
+	"const char domain[] =".
+
+2017-08-31  H.J. Lu  <hongjiu.lu@intel.com>
+
+	[BZ #22051]
+	* Makerules (build-module-helper-objlist): Filter out
+	$(elf-objpfx)sofini.os.
+	(build-shlib-objlist): Append $(elf-objpfx)sofini.os if it is
+	needed.
+
+2017-08-30  Florian Weimer  <fweimer@redhat.com>
+
+	* malloc/dynarray_emplace_enlarge.c
+	(__libc_dynarray_emplace_enlarge): Set errno on overflow.
+	* malloc/dynarray_resize.c (__libc_dynarray_resize): Likewise.
+	* malloc/tst-dynarray.c (test_long_overflow): New function.
+	(do_test): Call it.
+
+2017-09-06  Florian Weimer  <fweimer@redhat.com>
+
+	* malloc/dynarray_emplace_enlarge.c
+	(__libc_dynarray_emplace_enlarge): Add missing else.
+
+2017-09-06  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #22096]
+	* resolv/resolv_conf.c (__resolv_conf_attach): Do not free conf in
+	case of failure to obtain the global conf object.
+
+2017-09-06  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #22095]
+	* resolv/res_init.c (res_vinit_1): Avoid memory leak in case of
+	dynarray allocation failure.
+
+2017-09-06  Florian Weimer  <fweimer@redhat.com>
+
+	Remove dead PTR IPv4-to-IPv6 mapping code from nss_dns.
+	* resolv/nss_dns/dns-host.c (getanswer_r): Remove dead code.
+	* resolv/tst-res_use_inet6.c (response_ptr_v4, response_ptr_v6):
+	New functions.
+	(response): Call them.  Add 'p', '6' flag processing.
+	(test_reverse): New function.
+	(test_get2_any): Call it.
+	(test_no_inet6): Add 'p' test.
+	(test_inet6): Likewise.
+
+2017-09-06  Florian Weimer  <fweimer@redhat.com>
+
+	Enhance tst-res_use_inet6 to test IPv4-to-IPv6 address mapping.
+	* resolv/tst-res_use_inet6.c (response): Process flags embedded in
+	the QNAME.
+	(test_gai): Adjust query names.  Add additional tests.
+	(test_get2_any, test_get2_no_inet6, test_get2_inet6): Split from
+	test_get2.  Adjust query names.  Add additional tests.
+	(test_no_inet6): New function, extracted from threadfunc.
+	(threadfunc): Call test_get2_any, test_get2_inet6, test_no_inet6.
+	Add additional tests.
+
+2017-09-01  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #21915]
+	[BZ #21922]
+	* sysdeps/posix/getaddrinfo.c (gethosts): Look at NSS function
+	result to determine success or failure, not the errno value.
+	* nss/Makefile (tests): Add tst-nss-files-hosts-erange.
+	(tst-nss-files-hosts-erange): Link with -ldl.
+	* nss/tst-nss-files-hosts-erange.c: New file.
+	* nss/tst-resolv-basic.c (response): Handle nodata.example.
+	(do_test): Add NO_DATA tests.
+	* resolv/tst-resolv-basic.c (test_nodata_nxdomain): New function.
+	(do_test): Call it.
+
+2017-09-01  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #21922]
+	* sysdeps/posix/getaddrinfo.c (gaih_inet): Report EAI_NODATA error
+	coming from gethostbyname2_r.
+
+2017-09-01  Florian Weimer  <fweimer@redhat.com>
+
+	* sysdeps/posix/getaddrinfo.c (gaih_inet): Only use h_errno if
+	status indicates it is set.
+
+2017-09-01  Florian Weimer  <fweimer@redhat.com>
+
+	* sysdeps/posix/getaddrinfo.c (gaih_inet): Make reporting of NSS
+	function lookup failures more reliable.
+
+2017-09-01  Florian Weimer  <fweimer@redhat.com>
+
+	* sysdeps/posix/getaddrinfo.c (gethosts): Use h_errno directly.
+	(getcanonname): Likewise.
+	(gaih_inet): Likewise.
+
+2017-09-01  Florian Weimer  <fweimer@redhat.com>
+
+	* sysdeps/posix/getaddrinfo.c (gethosts): Use errno directly.
+	(getcanonname): Likewise.
+	(gaih_inet): Likewise.
+
+2017-08-08  Florian Weimer  <fweimer@redhat.com>
+
+	* sysdeps/posix/getaddrinfo.c (gaih_inet): Remove unreachable
+	return statement.
+
+2017-08-22  Joseph Myers  <joseph@codesourcery.com>
+
+	* assert/Makefile [$(have-cxx-thread_local)]: Move conditional
+	variable definitions above inclusion of ../Rules.
+
+2017-08-28  Gabriel F. T. Gomes  <gftg@linux.vnet.ibm.com>
+
+	[BZ #21930]
+	* math/math.h [defined __cplusplus && defined __SUPPORT_SNAN__]
+	(iszero): New C++ implementation that does not use
+	fpclassify/__MATH_TG/__builtin_types_compatible_p, when
+	signaling nans are enabled, since __builtin_types_compatible_p
+	is a C-only feature.
+	* math/test-math-iszero.cc: When __HAVE_DISTINCT_FLOAT128 is
+	defined, include ieee754_float128.h for access to the union and
+	member ieee854_float128.ieee.
+	[__HAVE_DISTINCT_FLOAT128] (do_test): Call check_float128.
+	[__HAVE_DISTINCT_FLOAT128] (check_float128): New function.
+	* sysdeps/powerpc/powerpc64le/Makefile [subdir == math]
+	(CXXFLAGS-test-math-iszero.cc): Add -mfloat128 to the build
+	options of test-math-zero on powerpc64le.
+
+2017-08-24  Gabriel F. T. Gomes  <gftg@linux.vnet.ibm.com>
+
+	* math/math.h [defined __cplusplus] (issignaling): In the long
+	double case, call __issignalingl only if __NO_LONG_DOUBLE_MATH
+	is not defined.  Call __issignaling, otherwise.
+
+2017-08-22  Gabriel F. T. Gomes  <gftg@linux.vnet.ibm.com>
+
+	* math/math.h [defined __cplusplus] (issignaling): Provide a C++
+	definition for issignaling that does not rely on __MATH_TG,
+	since __MATH_TG uses __builtin_types_compatible_p, which is only
+	available in C mode.
+	(CFLAGS-test-math-issignaling.cc): New variable.
+	* math/Makefile [CXX] (tests): Add test-math-issignaling.
+	* math/test-math-issignaling.cc: New test for C++ implementation
+	of type-generic issignaling.
+	* sysdeps/powerpc/powerpc64le/Makefile [subdir == math]
+	(CXXFLAGS-test-math-issignaling.cc): Add -mfloat128 to the build
+	options of test-math-issignaling on powerpc64le.
+
+2017-08-16  Andreas Schwab  <schwab@suse.de>
+
+	[BZ #16750]
+	CVE-2009-5064
+	* elf/ldd.bash.in: Never run file directly.
+
+2017-08-10  Florian Weimer  <fweimer@redhat.com>
+
+	* inet/net-internal.h (__inet6_scopeid_pton): Remove
+	attribute_hidden, internal_function.
+	* inet/inet6_scopeid_pton.c (__inet6_scopeid_pton): Remove
+	internal_function.
+
+2017-08-21  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #21972]
+	* assert/assert.h (assert): Use static_cast (bool) for C++.
+	Use the ternary operator in the warning branch for GNU C.
+	* assert/Makefile (tests): Add tst-assert-c++, tst-assert-g++.
+	(CFLAGS-tst-assert-c++.o): Compile in C++11 mode.
+	(CFLAGS-tst-assert-g++.o): Compile in GnU C++11 mode.
+	(LDLIBS-tst-assert-c++, LDLIBS-tst-assert-g++): Link with libstdc++.
+	* assert/tst-assert-c++.cc, assert/tst-assert-g++.cc: New files.
+
+2017-08-18  Gabriel F. T. Gomes  <gftg@linux.vnet.ibm.com>
+
+	* misc/sys/cdefs.h (__HAVE_GENERIC_SELECTION): Define to 0, if
+	in C++ mode.
+
+2017-08-18  Gabriel F. T. Gomes  <gftg@linux.vnet.ibm.com>
+
+	[BZ #21930]
+	* math/math.h (isinf): Check if in C or C++ mode before using
+	__builtin_types_compatible_p, since this is a C mode feature.
+
+2017-08-10  Gabriel F. T. Gomes  <gftg@linux.vnet.ibm.com>
+
+	[BZ #21941]
+	* sysdeps/powerpc/fpu/math_private.h (__ieee754_sqrtf128): Since
+	xssqrtqp requires operands to be in Vector Registers
+	(Altivec/VMX), replace the register constraint 'wq' with 'v'.
+	* sysdeps/powerpc/powerpc64le/power9/fpu/e_sqrtf128.c
+	(__ieee754_sqrtf128): Likewise.
+
+2017-08-11  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #21242]
+	* assert/assert.h [__GNUC__ && !__STRICT_ANSI__] (assert):
+	Suppress pedantic warning resulting from statement expression.
+	(__ASSERT_FUNCTION): Add missing __extension__.
+
+2017-08-10  Florian Weimer  <fweimer@redhat.com>
+
+	* malloc/malloc.c (get_max_fast): Reimplement as an inline
+	function which calls __builtin_unreachable.
+
+2017-08-09  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #21932]
+	* nss/getXXbyYY_r.c (REENTRANT_NAME): Call __resolv_context_put
+	before early return.
+
+2017-08-09  Adhemerval Zanella  <adhemerval.zanella@linaro.org>
+
+	[BZ #21780]
+	* sysdeps/posix/preadv2.c (preadv2): Use ENOTSUP instead of
+	EOPNOTSUPP.
+	* sysdeps/posix/preadv64v2.c (preadv64v2): Likewise.
+	* sysdeps/posix/pwritev2.c (pwritev2): Likewise.
+	* sysdeps/posix/pwritev64v2.c (pwritev64v2): Likewise.
+	* sysdeps/unix/sysv/linux/preadv2.c (preadv2): Likewise.
+	* sysdeps/unix/sysv/linux/preadv64v2.c (preadv64v2): Likewise.
+	* sysdeps/unix/sysv/linux/pwritev2.c (pwritev2): Likewise.
+	* sysdeps/unix/sysv/linux/pwritev64v2.c (pwritev64v2): Likewise.
+
+2017-08-06  H.J. Lu  <hongjiu.lu@intel.com>
+
+	[BZ #21871]
+	* sysdeps/x86/cpu-features.c (init_cpu_features): Set
+	bit_arch_Use_dl_runtime_resolve_opt only with AVX512F.
+
+2017-08-03  Aurelien Jarno  <aurelien@aurel32.net>
+
+	* stdlib/getentropy.c (getentropy): Change return type to int.
+
+2017-08-03  Aurelien Jarno  <aurelien@aurel32.net>
+
+	* sysdeps/i386/i686/fpu/multiarch/libm-test-ulps: Regenerated.
+
+2017-08-03  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #21885]
+	* sysdeps/posix/getaddrinfo.c (gethosts): Release resolver context
+	on memory allocation failure.
+
 2017-08-02  Siddhesh Poyarekar  <siddhesh@sourceware.org>
 
 	* version.h (RELEASE): Set to "stable"
diff --git a/Makerules b/Makerules
index 9bb707c168..828a445f24 100644
--- a/Makerules
+++ b/Makerules
@@ -686,14 +686,17 @@ $(build-module-helper) -o $@ $(shlib-lds-flags) \
 $(call after-link,$@)
 endef
 
+# sofini.os must be placed last since it terminates .eh_frame section.
 build-module-helper-objlist = \
 	$(patsubst %_pic.a,$(whole-archive) %_pic.a $(no-whole-archive),\
 		   $(filter-out %.lds $(map-file) $(+preinit) $(+postinit) \
+				$(elf-objpfx)sofini.os \
 				$(link-libc-deps),$^))
 
 build-module-objlist = $(build-module-helper-objlist) $(LDLIBS-$(@F:%.so=%).so)
 build-shlib-objlist = $(build-module-helper-objlist) \
-		      $(LDLIBS-$(@F:lib%.so=%).so)
+		      $(LDLIBS-$(@F:lib%.so=%).so) \
+		      $(filter $(elf-objpfx)sofini.os,$^)
 
 # Don't try to use -lc when making libc.so itself.
 # Also omits crti.o and crtn.o, which we do not want
diff --git a/NEWS b/NEWS
index 8295f20c0a..9bcb176171 100644
--- a/NEWS
+++ b/NEWS
@@ -5,6 +5,32 @@ See the end for copying conditions.
 Please send GNU C library bug reports via <http://sourceware.org/bugzilla/>
 using `glibc' in the "product" field.
 
+Version 2.26.1
+
+Security related changes:
+
+  CVE-2009-5064: The ldd script would sometimes run the program under
+  examination directly, without preventing code execution through the
+  dynamic linker.  (The glibc project disputes that this is a security
+  vulnerability; only trusted binaries must be examined using the ldd
+  script.)
+
+The following bugs are resolved with this release:
+
+  [16750] ldd: Never run file directly.
+  [21242] assert: Suppress pedantic warning caused by statement expression
+  [21780] posix: Set p{read,write}v2 to return ENOTSUP
+  [21871] x86-64: Use _dl_runtime_resolve_opt only with AVX512F
+  [21885] getaddrinfo: Release resolver context on error in gethosts
+  [21915] getaddrinfo: incorrect result handling for NSS service modules
+  [21922] getaddrinfo with AF_INET(6) returns EAI_NONAME, not EAI_NODATA
+  [21930] Do not use __builtin_types_compatible_p in C++ mode
+  [21932] Unpaired __resolv_context_get in generic get*_r implementation
+  [21941] powerpc: Restrict xssqrtqp operands to Vector Registers
+  [21972] assert macro requires operator== (int) for its argument type
+  [22095] resolv: Fix memory leak with OOM during resolv.conf parsing
+  [22096] resolv: __resolv_conf_attach must not free passed conf object
+
 Version 2.26
 
 Major new features:
diff --git a/assert/Makefile b/assert/Makefile
index 1c3be9b01f..222ab516f0 100644
--- a/assert/Makefile
+++ b/assert/Makefile
@@ -25,6 +25,15 @@ include ../Makeconfig
 headers	:= assert.h
 
 routines := assert assert-perr __assert
-tests := test-assert test-assert-perr
+tests := test-assert test-assert-perr tst-assert-c++ tst-assert-g++
+
+ifeq ($(have-cxx-thread_local),yes)
+CFLAGS-tst-assert-c++.o = -std=c++11
+LDLIBS-tst-assert-c++ = -lstdc++
+CFLAGS-tst-assert-g++.o = -std=gnu++11
+LDLIBS-tst-assert-g++ = -lstdc++
+else
+tests-unsupported += tst-assert-c++ tst-assert-g++
+endif
 
 include ../Rules
diff --git a/assert/assert.h b/assert/assert.h
index 22f019537c..640c95c063 100644
--- a/assert/assert.h
+++ b/assert/assert.h
@@ -85,19 +85,29 @@ __END_DECLS
 /* When possible, define assert so that it does not add extra
    parentheses around EXPR.  Otherwise, those added parentheses would
    suppress warnings we'd expect to be detected by gcc's -Wparentheses.  */
-# if !defined __GNUC__ || defined __STRICT_ANSI__
+# if defined __cplusplus
+#  define assert(expr)							\
+     (static_cast <bool> (expr)						\
+      ? void (0)							\
+      : __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION))
+# elif !defined __GNUC__ || defined __STRICT_ANSI__
 #  define assert(expr)							\
     ((expr)								\
      ? __ASSERT_VOID_CAST (0)						\
      : __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION))
 # else
+/* The first occurrence of EXPR is not evaluated due to the sizeof,
+   but will trigger any pedantic warnings masked by the __extension__
+   for the second occurrence.  The ternary operator is required to
+   support function pointers and bit fields in this context, and to
+   suppress the evaluation of variable length arrays.  */
 #  define assert(expr)							\
-    ({									\
+  ((void) sizeof ((expr) ? 1 : 0), __extension__ ({			\
       if (expr)								\
         ; /* empty */							\
       else								\
         __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION);	\
-    })
+    }))
 # endif
 
 # ifdef	__USE_GNU
@@ -113,7 +123,7 @@ __END_DECLS
    C9x has a similar variable called __func__, but prefer the GCC one since
    it demangles C++ function names.  */
 # if defined __cplusplus ? __GNUC_PREREQ (2, 6) : __GNUC_PREREQ (2, 4)
-#   define __ASSERT_FUNCTION	__PRETTY_FUNCTION__
+#   define __ASSERT_FUNCTION	__extension__ __PRETTY_FUNCTION__
 # else
 #  if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
 #   define __ASSERT_FUNCTION	__func__
diff --git a/assert/tst-assert-c++.cc b/assert/tst-assert-c++.cc
new file mode 100644
index 0000000000..12a5e690cb
--- /dev/null
+++ b/assert/tst-assert-c++.cc
@@ -0,0 +1,78 @@
+/* Tests for interactions between C++ and assert.
+   Copyright (C) 2017 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <assert.h>
+
+/* The C++ standard requires that if the assert argument is a constant
+   subexpression, then the assert itself is one, too.  */
+constexpr int
+check_constexpr ()
+{
+  return (assert (true), 1);
+}
+
+/* Objects of this class can be contextually converted to bool, but
+   cannot be compared to int.  */
+struct no_int
+{
+  no_int () = default;
+  no_int (const no_int &) = delete;
+
+  explicit operator bool () const
+  {
+    return true;
+  }
+
+  bool operator! () const; /* No definition.  */
+  template <class T> bool operator== (T) const; /* No definition.  */
+  template <class T> bool operator!= (T) const; /* No definition.  */
+};
+
+/* This class tests that operator== is not used by assert.  */
+struct bool_and_int
+{
+  bool_and_int () = default;
+  bool_and_int (const no_int &) = delete;
+
+  explicit operator bool () const
+  {
+    return true;
+  }
+
+  bool operator! () const; /* No definition.  */
+  template <class T> bool operator== (T) const; /* No definition.  */
+  template <class T> bool operator!= (T) const; /* No definition.  */
+};
+
+static int
+do_test ()
+{
+  {
+    no_int value;
+    assert (value);
+  }
+
+  {
+    bool_and_int value;
+    assert (value);
+  }
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/assert/tst-assert-g++.cc b/assert/tst-assert-g++.cc
new file mode 100644
index 0000000000..8c06402825
--- /dev/null
+++ b/assert/tst-assert-g++.cc
@@ -0,0 +1,19 @@
+/* Tests for interactions between C++ and assert.  GNU C++11 version.
+   Copyright (C) 2017 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <tst-assert-c++.cc>
diff --git a/elf/ldd.bash.in b/elf/ldd.bash.in
index 7dd1fccf24..686785e235 100644
--- a/elf/ldd.bash.in
+++ b/elf/ldd.bash.in
@@ -164,18 +164,6 @@ warning: you do not have execution permission for" "\`$file'" >&2
       fi
     done
     case $ret in
-    0)
-      # If the program exits with exit code 5, it means the process has been
-      # invoked with __libc_enable_secure.  Fall back to running it through
-      # the dynamic linker.
-      try_trace "$file"
-      rc=$?
-      if [ $rc = 5 ]; then
-	try_trace "$RTLD" "$file"
-	rc=$?
-      fi
-      [ $rc = 0 ] || result=1
-      ;;
     1)
       # This can be a non-ELF binary or no binary at all.
       nonelf "$file" || {
@@ -183,7 +171,7 @@ warning: you do not have execution permission for" "\`$file'" >&2
 	result=1
       }
       ;;
-    2)
+    0|2)
       try_trace "$RTLD" "$file" || result=1
       ;;
     *)
diff --git a/inet/inet6_scopeid_pton.c b/inet/inet6_scopeid_pton.c
index e09b1cb34d..cc8803fa10 100644
--- a/inet/inet6_scopeid_pton.c
+++ b/inet/inet6_scopeid_pton.c
@@ -28,7 +28,7 @@
 
 /* Parse SOURCE as a scope ID for ADDRESS.  Return 0 on success and -1
    on error.  */
-internal_function int
+int
 __inet6_scopeid_pton (const struct in6_addr *address, const char *scope,
                       uint32_t *result)
 {
diff --git a/inet/net-internal.h b/inet/net-internal.h
index 2b2632c7ba..b2135893e8 100644
--- a/inet/net-internal.h
+++ b/inet/net-internal.h
@@ -25,8 +25,7 @@
 #include <sys/time.h>
 
 int __inet6_scopeid_pton (const struct in6_addr *address,
-                          const char *scope, uint32_t *result)
-  internal_function attribute_hidden;
+                          const char *scope, uint32_t *result);
 libc_hidden_proto (__inet6_scopeid_pton)
 
 
diff --git a/malloc/dynarray_emplace_enlarge.c b/malloc/dynarray_emplace_enlarge.c
index dfc70017ce..a15245f4cb 100644
--- a/malloc/dynarray_emplace_enlarge.c
+++ b/malloc/dynarray_emplace_enlarge.c
@@ -17,6 +17,7 @@
    <http://www.gnu.org/licenses/>.  */
 
 #include <dynarray.h>
+#include <errno.h>
 #include <malloc-internal.h>
 #include <stdlib.h>
 #include <string.h>
@@ -32,7 +33,7 @@ __libc_dynarray_emplace_enlarge (struct dynarray_header *list,
          size.  */
       if (element_size < 4)
         new_allocated = 16;
-      if (element_size < 8)
+      else if (element_size < 8)
         new_allocated = 8;
       else
         new_allocated = 4;
@@ -43,8 +44,11 @@ __libc_dynarray_emplace_enlarge (struct dynarray_header *list,
     {
       new_allocated = list->allocated + list->allocated / 2 + 1;
       if (new_allocated <= list->allocated)
-        /* Overflow.  */
-        return false;
+        {
+          /* Overflow.  */
+          __set_errno (ENOMEM);
+          return false;
+        }
     }
 
   size_t new_size;
diff --git a/malloc/dynarray_resize.c b/malloc/dynarray_resize.c
index e6dc9fbc68..63c981bf61 100644
--- a/malloc/dynarray_resize.c
+++ b/malloc/dynarray_resize.c
@@ -17,6 +17,7 @@
    <http://www.gnu.org/licenses/>.  */
 
 #include <dynarray.h>
+#include <errno.h>
 #include <malloc-internal.h>
 #include <stdlib.h>
 #include <string.h>
@@ -38,7 +39,11 @@ __libc_dynarray_resize (struct dynarray_header *list, size_t size,
 
   size_t new_size_bytes;
   if (check_mul_overflow_size_t (size, element_size, &new_size_bytes))
-    return false;
+    {
+      /* Overflow.  */
+      __set_errno (ENOMEM);
+      return false;
+    }
   void *new_array;
   if (list->array == scratch)
     {
diff --git a/malloc/malloc.c b/malloc/malloc.c
index 54e406bcb6..e3ff778113 100644
--- a/malloc/malloc.c
+++ b/malloc/malloc.c
@@ -1658,6 +1658,9 @@ typedef struct malloc_chunk *mfastbinptr;
 #define arena_is_corrupt(A)	(((A)->flags & ARENA_CORRUPTION_BIT))
 #define set_arena_corrupt(A)	((A)->flags |= ARENA_CORRUPTION_BIT)
 
+/* Maximum size of memory handled in fastbins.  */
+static INTERNAL_SIZE_T global_max_fast;
+
 /*
    Set value of max_fast.
    Use impossibly small value if 0.
@@ -1668,8 +1671,20 @@ typedef struct malloc_chunk *mfastbinptr;
 #define set_max_fast(s) \
   global_max_fast = (((s) == 0)						      \
                      ? SMALLBIN_WIDTH : ((s + SIZE_SZ) & ~MALLOC_ALIGN_MASK))
-#define get_max_fast() global_max_fast
 
+static inline INTERNAL_SIZE_T
+get_max_fast (void)
+{
+  /* Tell the GCC optimizers that global_max_fast is never larger
+     than MAX_FAST_SIZE.  This avoids out-of-bounds array accesses in
+     _int_malloc after constant propagation of the size parameter.
+     (The code never executes because malloc preserves the
+     global_max_fast invariant, but the optimizers may not recognize
+     this.)  */
+  if (global_max_fast > MAX_FAST_SIZE)
+    __builtin_unreachable ();
+  return global_max_fast;
+}
 
 /*
    ----------- Internal state representation and initialization -----------
@@ -1797,9 +1812,6 @@ static struct malloc_par mp_ =
 #endif
 };
 
-/* Maximum size of memory handled in fastbins.  */
-static INTERNAL_SIZE_T global_max_fast;
-
 /*
    Initialize a malloc_state struct.
 
diff --git a/malloc/tst-dynarray.c b/malloc/tst-dynarray.c
index 2206d75e31..d11f7bb8a3 100644
--- a/malloc/tst-dynarray.c
+++ b/malloc/tst-dynarray.c
@@ -18,6 +18,9 @@
 
 #include "tst-dynarray-shared.h"
 
+#include <errno.h>
+#include <stdint.h>
+
 #define DYNARRAY_STRUCT dynarray_long
 #define DYNARRAY_ELEMENT long
 #define DYNARRAY_PREFIX dynarray_long_
@@ -463,6 +466,31 @@ test_long_init (void)
   }
 }
 
+/* Test overflow in resize.  */
+static void
+test_long_overflow (void)
+{
+  {
+    struct dynarray_long dyn;
+    dynarray_long_init (&dyn);
+    errno = EINVAL;
+    TEST_VERIFY (!dynarray_long_resize
+                 (&dyn, (SIZE_MAX / sizeof (long)) + 1));
+    TEST_VERIFY (errno == ENOMEM);
+    TEST_VERIFY (dynarray_long_has_failed (&dyn));
+  }
+
+  {
+    struct dynarray_long_noscratch dyn;
+    dynarray_long_noscratch_init (&dyn);
+    errno = EINVAL;
+    TEST_VERIFY (!dynarray_long_noscratch_resize
+                 (&dyn, (SIZE_MAX / sizeof (long)) + 1));
+    TEST_VERIFY (errno == ENOMEM);
+    TEST_VERIFY (dynarray_long_noscratch_has_failed (&dyn));
+  }
+}
+
 /* Test NUL-terminated string construction with the add function and
    the simple finalize function.  */
 static void
@@ -538,6 +566,7 @@ do_test (void)
   test_int ();
   test_str ();
   test_long_init ();
+  test_long_overflow ();
   test_zstr ();
   return 0;
 }
diff --git a/math/Makefile b/math/Makefile
index e09b0c0545..0130fcf38b 100644
--- a/math/Makefile
+++ b/math/Makefile
@@ -203,7 +203,7 @@ tests-static = test-fpucw-static test-fpucw-ieee-static \
 	       test-signgam-ullong-static test-signgam-ullong-init-static
 
 ifneq (,$(CXX))
-tests += test-math-isinff test-math-iszero
+tests += test-math-isinff test-math-iszero test-math-issignaling
 endif
 
 ifneq (no,$(PERL))
@@ -350,6 +350,7 @@ CFLAGS-test-signgam-ullong-init-static.c = -std=c99
 
 CFLAGS-test-math-isinff.cc = -std=gnu++11
 CFLAGS-test-math-iszero.cc = -std=gnu++11
+CFLAGS-test-math-issignaling.cc = -std=gnu++11
 
 CFLAGS-test-iszero-excess-precision.c = -fexcess-precision=standard
 CFLAGS-test-iseqsig-excess-precision.c = -fexcess-precision=standard
diff --git a/math/math.h b/math/math.h
index e21708045a..7c0fc6dbb3 100644
--- a/math/math.h
+++ b/math/math.h
@@ -442,8 +442,12 @@ enum
 
 /* Return nonzero value if X is positive or negative infinity.  */
 # if __HAVE_DISTINCT_FLOAT128 && !__GNUC_PREREQ (7,0) \
-     && !defined __SUPPORT_SNAN__
-   /* __builtin_isinf_sign is broken for float128 only before GCC 7.0.  */
+     && !defined __SUPPORT_SNAN__ && !defined __cplusplus
+   /* Since __builtin_isinf_sign is broken for float128 before GCC 7.0,
+      use the helper function, __isinff128, with older compilers.  This is
+      only provided for C mode, because in C++ mode, GCC has no support
+      for __builtin_types_compatible_p (and when in C++ mode, this macro is
+      not used anyway, because libstdc++ headers undefine it).  */
 #  define isinf(x) \
     (__builtin_types_compatible_p (__typeof (x), _Float128) \
      ? __isinff128 (x) : __builtin_isinf_sign (x))
@@ -470,7 +474,32 @@ enum
 # include <bits/iscanonical.h>
 
 /* Return nonzero value if X is a signaling NaN.  */
-# define issignaling(x) __MATH_TG ((x), __issignaling, (x))
+# ifndef __cplusplus
+#  define issignaling(x) __MATH_TG ((x), __issignaling, (x))
+# else
+   /* In C++ mode, __MATH_TG cannot be used, because it relies on
+      __builtin_types_compatible_p, which is a C-only builtin.  On the
+      other hand, overloading provides the means to distinguish between
+      the floating-point types.  The overloading resolution will match
+      the correct parameter (regardless of type qualifiers (i.e.: const
+      and volatile).  */
+extern "C++" {
+inline int issignaling (float __val) { return __issignalingf (__val); }
+inline int issignaling (double __val) { return __issignaling (__val); }
+inline int
+issignaling (long double __val)
+{
+#  ifdef __NO_LONG_DOUBLE_MATH
+  return __issignaling (__val);
+#  else
+  return __issignalingl (__val);
+#  endif
+}
+#  if __HAVE_DISTINCT_FLOAT128
+inline int issignaling (_Float128 __val) { return __issignalingf128 (__val); }
+#  endif
+} /* extern C++ */
+# endif
 
 /* Return nonzero value if X is subnormal.  */
 # define issubnormal(x) (fpclassify (x) == FP_SUBNORMAL)
@@ -484,15 +513,40 @@ enum
 #  endif
 # else	/* __cplusplus */
 extern "C++" {
+#  ifdef __SUPPORT_SNAN__
+inline int
+iszero (float __val)
+{
+  return __fpclassifyf (__val) == FP_ZERO;
+}
+inline int
+iszero (double __val)
+{
+  return __fpclassify (__val) == FP_ZERO;
+}
+inline int
+iszero (long double __val)
+{
+#   ifdef __NO_LONG_DOUBLE_MATH
+  return __fpclassify (__val) == FP_ZERO;
+#   else
+  return __fpclassifyl (__val) == FP_ZERO;
+#   endif
+}
+#   if __HAVE_DISTINCT_FLOAT128
+inline int
+iszero (_Float128 __val)
+{
+  return __fpclassifyf128 (__val) == FP_ZERO;
+}
+#   endif
+#  else
 template <class __T> inline bool
 iszero (__T __val)
 {
-#  ifdef __SUPPORT_SNAN__
-  return fpclassify (__val) == FP_ZERO;
-#  else
   return __val == 0;
-#  endif
 }
+#  endif
 } /* extern C++ */
 # endif	/* __cplusplus */
 #endif /* Use IEC_60559_BFP_EXT.  */
diff --git a/math/test-math-issignaling.cc b/math/test-math-issignaling.cc
new file mode 100644
index 0000000000..22ae9e1bca
--- /dev/null
+++ b/math/test-math-issignaling.cc
@@ -0,0 +1,113 @@
+/* Test for the C++ implementation of issignaling.
+   Copyright (C) 2017 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define _GNU_SOURCE 1
+#include <math.h>
+#include <stdio.h>
+
+#include <limits>
+
+/* There is no signaling_NaN for _Float128 in std::numeric_limits.
+   Include ieee754_float128.h and use the bitfields in the union
+   ieee854_float128.ieee_nan to build a signaling NaN.  */
+#if __HAVE_DISTINCT_FLOAT128
+# include <ieee754_float128.h>
+#endif
+
+static bool errors;
+
+static void
+check (int actual, int expected, const char *actual_expr, int line)
+{
+  if (actual != expected)
+    {
+      errors = true;
+      printf ("%s:%d: error: %s\n", __FILE__, line, actual_expr);
+      printf ("%s:%d:   expected: %d\n", __FILE__, line, expected);
+      printf ("%s:%d:   actual: %d\n", __FILE__, line, actual);
+    }
+}
+
+#define CHECK(actual, expected) \
+  check ((actual), (expected), #actual, __LINE__)
+
+template <class T>
+static void
+check_type ()
+{
+  typedef std::numeric_limits<T> limits;
+  CHECK (issignaling (T{0}), 0);
+  if (limits::has_infinity)
+    {
+      CHECK (issignaling (limits::infinity ()), 0);
+      CHECK (issignaling (-limits::infinity ()), 0);
+    }
+  if (limits::has_quiet_NaN)
+    CHECK (issignaling (limits::quiet_NaN ()), 0);
+  if (limits::has_signaling_NaN)
+    CHECK (issignaling (limits::signaling_NaN ()), 1);
+}
+
+#if __HAVE_DISTINCT_FLOAT128
+static void
+check_float128 ()
+{
+  ieee854_float128 q;
+
+  q.d = 0;
+  CHECK (issignaling (q.d), 0);
+
+  /* Infinity.  */
+  q.ieee.negative = 0;
+  q.ieee.exponent = 0x7FFF;
+  q.ieee.mantissa0 = 0x0000;
+  q.ieee.mantissa1 = 0x00000000;
+  q.ieee.mantissa2 = 0x00000000;
+  q.ieee.mantissa3 = 0x00000000;
+  CHECK (issignaling (q.d), 0);
+
+  /* Quiet NaN.  */
+  q.ieee_nan.quiet_nan = 1;
+  q.ieee_nan.mantissa0 = 0x0000;
+  CHECK (issignaling (q.d), 0);
+
+  /* Still a quiet NaN.  */
+  q.ieee_nan.quiet_nan = 1;
+  q.ieee_nan.mantissa0 = 0x4000;
+  CHECK (issignaling (q.d), 0);
+
+  /* Signaling NaN.  */
+  q.ieee_nan.quiet_nan = 0;
+  q.ieee_nan.mantissa0 = 0x4000;
+  CHECK (issignaling (q.d), 1);
+}
+#endif
+
+static int
+do_test (void)
+{
+  check_type<float> ();
+  check_type<double> ();
+  check_type<long double> ();
+#if __HAVE_DISTINCT_FLOAT128
+  check_float128 ();
+#endif
+  return errors;
+}
+
+#include <support/test-driver.c>
diff --git a/math/test-math-iszero.cc b/math/test-math-iszero.cc
index 027e972654..5c07261626 100644
--- a/math/test-math-iszero.cc
+++ b/math/test-math-iszero.cc
@@ -22,6 +22,13 @@
 
 #include <limits>
 
+/* Support for _Float128 in std::numeric_limits is limited.
+   Include ieee754_float128.h and use the bitfields in the union
+   ieee854_float128.ieee_nan to build corner-case inputs.  */
+#if __HAVE_DISTINCT_FLOAT128
+# include <ieee754_float128.h>
+#endif
+
 static bool errors;
 
 static void
@@ -72,12 +79,84 @@ check_type ()
          std::numeric_limits<T>::has_denorm == std::denorm_absent);
 }
 
+#if __HAVE_DISTINCT_FLOAT128
+static void
+check_float128 ()
+{
+  ieee854_float128 q;
+
+  q.d = 0.0Q;
+  CHECK (iszero (q.d), 1);
+  q.d = -0.0Q;
+  CHECK (iszero (q.d), 1);
+  q.d = 1.0Q;
+  CHECK (iszero (q.d), 0);
+  q.d = -1.0Q;
+  CHECK (iszero (q.d), 0);
+
+  /* Normal min.  */
+  q.ieee.negative = 0;
+  q.ieee.exponent = 0x0001;
+  q.ieee.mantissa0 = 0x0000;
+  q.ieee.mantissa1 = 0x00000000;
+  q.ieee.mantissa2 = 0x00000000;
+  q.ieee.mantissa3 = 0x00000000;
+  CHECK (iszero (q.d), 0);
+  q.ieee.negative = 1;
+  CHECK (iszero (q.d), 0);
+
+  /* Normal max.  */
+  q.ieee.negative = 0;
+  q.ieee.exponent = 0x7FFE;
+  q.ieee.mantissa0 = 0xFFFF;
+  q.ieee.mantissa1 = 0xFFFFFFFF;
+  q.ieee.mantissa2 = 0xFFFFFFFF;
+  q.ieee.mantissa3 = 0xFFFFFFFF;
+  CHECK (iszero (q.d), 0);
+  q.ieee.negative = 1;
+  CHECK (iszero (q.d), 0);
+
+  /* Infinity.  */
+  q.ieee.negative = 0;
+  q.ieee.exponent = 0x7FFF;
+  q.ieee.mantissa0 = 0x0000;
+  q.ieee.mantissa1 = 0x00000000;
+  q.ieee.mantissa2 = 0x00000000;
+  q.ieee.mantissa3 = 0x00000000;
+  CHECK (iszero (q.d), 0);
+
+  /* Quiet NaN.  */
+  q.ieee_nan.quiet_nan = 1;
+  q.ieee_nan.mantissa0 = 0x0000;
+  CHECK (iszero (q.d), 0);
+
+  /* Signaling NaN.  */
+  q.ieee_nan.quiet_nan = 0;
+  q.ieee_nan.mantissa0 = 0x4000;
+  CHECK (iszero (q.d), 0);
+
+  /* Denormal min.  */
+  q.ieee.negative = 0;
+  q.ieee.exponent = 0x0000;
+  q.ieee.mantissa0 = 0x0000;
+  q.ieee.mantissa1 = 0x00000000;
+  q.ieee.mantissa2 = 0x00000000;
+  q.ieee.mantissa3 = 0x00000001;
+  CHECK (iszero (q.d), 0);
+  q.ieee.negative = 1;
+  CHECK (iszero (q.d), 0);
+}
+#endif
+
 static int
 do_test (void)
 {
   check_type<float> ();
   check_type<double> ();
   check_type<long double> ();
+#if __HAVE_DISTINCT_FLOAT128
+  check_float128 ();
+#endif
   return errors;
 }
 
diff --git a/misc/sys/cdefs.h b/misc/sys/cdefs.h
index 06523bfe9c..0c808216a4 100644
--- a/misc/sys/cdefs.h
+++ b/misc/sys/cdefs.h
@@ -464,17 +464,18 @@
 # define __glibc_macro_warning(msg)
 #endif
 
-/* Support for generic selection (ISO C11) is available in GCC since
-   version 4.9.  Previous versions do not provide generic selection,
-   even though they might set __STDC_VERSION__ to 201112L, when in
-   -std=c11 mode.  Thus, we must check for !defined __GNUC__ when
-   testing __STDC_VERSION__ for generic selection support.
+/* Generic selection (ISO C11) is a C-only feature, available in GCC
+   since version 4.9.  Previous versions do not provide generic
+   selection, even though they might set __STDC_VERSION__ to 201112L,
+   when in -std=c11 mode.  Thus, we must check for !defined __GNUC__
+   when testing __STDC_VERSION__ for generic selection support.
    On the other hand, Clang also defines __GNUC__, so a clang-specific
    check is required to enable the use of generic selection.  */
-#if __GNUC_PREREQ (4, 9) \
-    || __glibc_clang_has_extension (c_generic_selections) \
-    || (!defined __GNUC__ && defined __STDC_VERSION__ \
-	&& __STDC_VERSION__ >= 201112L)
+#if !defined __cplusplus \
+    && (__GNUC_PREREQ (4, 9) \
+	|| __glibc_clang_has_extension (c_generic_selections) \
+	|| (!defined __GNUC__ && defined __STDC_VERSION__ \
+	    && __STDC_VERSION__ >= 201112L))
 # define __HAVE_GENERIC_SELECTION 1
 #else
 # define __HAVE_GENERIC_SELECTION 0
diff --git a/nss/Makefile b/nss/Makefile
index d9f6d41181..91b1c21567 100644
--- a/nss/Makefile
+++ b/nss/Makefile
@@ -58,6 +58,11 @@ tests			= test-netdb test-digits-dots tst-nss-getpwent bug17079 \
 			  tst-nss-test5
 xtests			= bug-erange
 
+# Tests which need libdl
+ifeq (yes,$(build-shared))
+tests += tst-nss-files-hosts-erange
+endif
+
 # If we have a thread library then we can test cancellation against
 # some routines like getpwuid_r.
 ifeq (yes,$(have-thread-library))
@@ -154,3 +159,5 @@ $(patsubst %,$(objpfx)%.out,$(tests)) : \
 ifeq (yes,$(have-thread-library))
 $(objpfx)tst-cancel-getpwuid_r: $(shared-thread-library)
 endif
+
+$(objpfx)tst-nss-files-hosts-erange: $(libdl)
diff --git a/nss/getXXbyYY_r.c b/nss/getXXbyYY_r.c
index 6c547ea1ca..bce80e05dd 100644
--- a/nss/getXXbyYY_r.c
+++ b/nss/getXXbyYY_r.c
@@ -234,6 +234,9 @@ INTERNAL (REENTRANT_NAME) (ADD_PARAMS, LOOKUP_TYPE *resbuf, char *buffer,
 				      H_ERRNO_VAR_P))
     {
     case -1:
+# ifdef NEED__RES
+      __resolv_context_put (res_ctx);
+# endif
       return errno;
     case 1:
 #ifdef NEED_H_ERRNO
@@ -253,7 +256,12 @@ INTERNAL (REENTRANT_NAME) (ADD_PARAMS, LOOKUP_TYPE *resbuf, char *buffer,
       nscd_status = NSCD_NAME (ADD_VARIABLES, resbuf, buffer, buflen, result
 			       H_ERRNO_VAR);
       if (nscd_status >= 0)
-	return nscd_status;
+	{
+# ifdef NEED__RES
+	  __resolv_context_put (res_ctx);
+# endif
+	  return nscd_status;
+	}
     }
 #endif
 
diff --git a/nss/tst-nss-files-hosts-erange.c b/nss/tst-nss-files-hosts-erange.c
new file mode 100644
index 0000000000..beb7aa9fa0
--- /dev/null
+++ b/nss/tst-nss-files-hosts-erange.c
@@ -0,0 +1,109 @@
+/* Parse /etc/hosts in multi mode with a trailing long line (bug 21915).
+   Copyright (C) 2017 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+
+#include <dlfcn.h>
+#include <errno.h>
+#include <gnu/lib-names.h>
+#include <netdb.h>
+#include <nss.h>
+#include <support/check.h>
+#include <support/check_nss.h>
+#include <support/namespace.h>
+#include <support/test-driver.h>
+#include <support/xunistd.h>
+
+struct support_chroot *chroot_env;
+
+#define X10 "XXXXXXXXXX"
+#define X100 X10 X10 X10 X10 X10 X10 X10 X10 X10 X10
+#define X1000 X100 X100 X100 X100 X100 X100 X100 X100 X100 X100
+
+static void
+prepare (int argc, char **argv)
+{
+  chroot_env = support_chroot_create
+    ((struct support_chroot_configuration)
+     {
+       .resolv_conf = "",
+       .hosts =
+         "127.0.0.1   localhost localhost.localdomain\n"
+         "::1         localhost localhost.localdomain\n"
+         "192.0.2.1   example.com\n"
+         "#" X1000 X100 "\n",
+       .host_conf = "multi on\n",
+     });
+}
+
+static int
+do_test (void)
+{
+  support_become_root ();
+  if (!support_can_chroot ())
+    return EXIT_UNSUPPORTED;
+
+  __nss_configure_lookup ("hosts", "files");
+  if (dlopen (LIBNSS_FILES_SO, RTLD_LAZY) == NULL)
+    FAIL_EXIT1 ("could not load " LIBNSS_DNS_SO ": %s", dlerror ());
+
+  xchroot (chroot_env->path_chroot);
+
+  errno = ERANGE;
+  h_errno = NETDB_INTERNAL;
+  check_hostent ("gethostbyname example.com",
+                 gethostbyname ("example.com"),
+                 "name: example.com\n"
+                 "address: 192.0.2.1\n");
+  errno = ERANGE;
+  h_errno = NETDB_INTERNAL;
+  check_hostent ("gethostbyname2 AF_INET example.com",
+                 gethostbyname2 ("example.com", AF_INET),
+                 "name: example.com\n"
+                 "address: 192.0.2.1\n");
+  {
+    struct addrinfo hints =
+      {
+        .ai_family = AF_UNSPEC,
+        .ai_socktype = SOCK_STREAM,
+        .ai_protocol = IPPROTO_TCP,
+      };
+    errno = ERANGE;
+    h_errno = NETDB_INTERNAL;
+    struct addrinfo *ai;
+    int ret = getaddrinfo ("example.com", "80", &hints, &ai);
+    check_addrinfo ("example.com AF_UNSPEC", ai, ret,
+                    "address: STREAM/TCP 192.0.2.1 80\n");
+    if (ret == 0)
+      freeaddrinfo (ai);
+
+    hints.ai_family = AF_INET;
+    errno = ERANGE;
+    h_errno = NETDB_INTERNAL;
+    ret = getaddrinfo ("example.com", "80", &hints, &ai);
+    check_addrinfo ("example.com AF_INET", ai, ret,
+                    "address: STREAM/TCP 192.0.2.1 80\n");
+    if (ret == 0)
+      freeaddrinfo (ai);
+  }
+
+  support_chroot_free (chroot_env);
+  return 0;
+}
+
+#define PREPARE prepare
+#include <support/test-driver.c>
diff --git a/resolv/nss_dns/dns-host.c b/resolv/nss_dns/dns-host.c
index 7cd54ab504..1e85e4f08f 100644
--- a/resolv/nss_dns/dns-host.c
+++ b/resolv/nss_dns/dns-host.c
@@ -889,19 +889,6 @@ getanswer_r (struct resolv_context *ctx,
 	  /* bind would put multiple PTR records as aliases, but we don't do
 	     that.  */
 	  result->h_name = bp;
-	  if (have_to_map)
-	    {
-	      n = strlen (bp) + 1;	/* for the \0 */
-	      if (__glibc_unlikely (n >= MAXHOSTNAMELEN))
-		{
-		  ++had_error;
-		  break;
-		}
-	      bp += n;
-	      linebuflen -= n;
-	      if (map_v4v6_hostent (result, &bp, &linebuflen))
-		goto too_small;
-	    }
 	  *h_errnop = NETDB_SUCCESS;
 	  return NSS_STATUS_SUCCESS;
 	case T_A:
diff --git a/resolv/res_init.c b/resolv/res_init.c
index fa46ce7813..4e1f9fe8de 100644
--- a/resolv/res_init.c
+++ b/resolv/res_init.c
@@ -446,6 +446,11 @@ res_vinit_1 (FILE *fp, struct resolv_conf_parser *parser)
                     (&parser->nameserver_list);
                   if (p != NULL)
                     *p = sa;
+                  else
+                    {
+                      free (sa);
+                      return false;
+                    }
                 }
               continue;
             }
diff --git a/resolv/resolv_conf.c b/resolv/resolv_conf.c
index f391d30c27..e0f296d02e 100644
--- a/resolv/resolv_conf.c
+++ b/resolv/resolv_conf.c
@@ -600,10 +600,7 @@ __resolv_conf_attach (struct __res_state *resp, struct resolv_conf *conf)
 
   struct resolv_conf_global *global_copy = get_locked_global ();
   if (global_copy == NULL)
-    {
-      free (conf);
-      return false;
-    }
+    return false;
 
   /* Try to find an unused index in the array.  */
   size_t index;
diff --git a/resolv/tst-res_use_inet6.c b/resolv/tst-res_use_inet6.c
index 6f3db08892..d819f921d6 100644
--- a/resolv/tst-res_use_inet6.c
+++ b/resolv/tst-res_use_inet6.c
@@ -16,21 +16,121 @@
    License along with the GNU C Library; if not, see
    <http://www.gnu.org/licenses/>.  */
 
+#include <ctype.h>
 #include <netdb.h>
 #include <resolv.h>
+#include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
+#include <support/check.h>
 #include <support/check_nss.h>
 #include <support/resolv_test.h>
+#include <support/support.h>
 #include <support/xthread.h>
 
+/* Handle IPv4 reverse lookup responses.  Product a PTR record
+   A-B-C-D.v4.example.  */
+static void
+response_ptr_v4 (const struct resolv_response_context *ctx,
+                 struct resolv_response_builder *b,
+                 const char *qname, uint16_t qclass, uint16_t qtype)
+{
+  int bytes[4];
+  int offset = -1;
+  TEST_VERIFY (sscanf (qname, "%d.%d.%d.%d.in-addr.arpa%n",
+                       bytes + 0, bytes + 1, bytes + 2, bytes + 3,
+                       &offset) == 4);
+  TEST_VERIFY (offset == strlen (qname));
+  resolv_response_init (b, (struct resolv_response_flags) {});
+  resolv_response_add_question (b, qname, qclass, qtype);
+  resolv_response_section (b, ns_s_an);
+  resolv_response_open_record (b, qname, qclass, T_PTR, 0);
+  char *name = xasprintf ("%d-%d-%d-%d.v4.example",
+                          bytes[3], bytes[2], bytes[1], bytes[0]);
+  resolv_response_add_name (b, name);
+  free (name);
+  resolv_response_close_record (b);
+}
+
+/* Handle IPv6 reverse lookup responses.  Produce a PTR record
+   <32 hex digits>.v6.example. */
+static void
+response_ptr_v6 (const struct resolv_response_context *ctx,
+                 struct resolv_response_builder *b,
+                 const char *qname, uint16_t qclass, uint16_t qtype)
+{
+
+  TEST_VERIFY_EXIT (strlen (qname) > 64);
+
+  char bytes[33];
+  for (int i = 0; i < 64; ++i)
+    if ((i % 2) == 0)
+      {
+        TEST_VERIFY (isxdigit ((unsigned char) qname[i]));
+        bytes[31 - i / 2] = qname[i];
+      }
+    else
+      TEST_VERIFY_EXIT (qname[i] == '.');
+  bytes[32] = '\0';
+
+    resolv_response_init (b, (struct resolv_response_flags) {});
+  resolv_response_add_question (b, qname, qclass, qtype);
+  resolv_response_section (b, ns_s_an);
+  resolv_response_open_record (b, qname, qclass, T_PTR, 0);
+  char *name = xasprintf ("%s.v6.example", bytes);
+  resolv_response_add_name (b, name);
+  free (name);
+  resolv_response_close_record (b);
+}
+
+/* Produce a response based on QNAME: Certain characters in the first
+   label of QNAME trigger the inclusion of resource records:
+
+   'a'   A record (IPv4 address)
+   'q'   AAAA record (quad A record, IPv6 address)
+   'p'   PTR record
+   'm'   record type must match QTYPE (no additional records)
+   '6'   stop flag processing if QTYPE == AAAA
+
+   For 'a' and 'q', QTYPE is ignored for record type selection if 'm'
+   is not specified.
+
+   in-addr.arpa and ip6.arpa queries are handled separately in
+   response_ptr_v4 and response_ptr_v6.  */
 static void
 response (const struct resolv_response_context *ctx,
           struct resolv_response_builder *b,
           const char *qname, uint16_t qclass, uint16_t qtype)
 {
-  bool include_both =  strcmp (qname, "both.example") == 0;
-  bool include_a = qtype == T_A || include_both;
-  bool include_aaaa = qtype == T_AAAA || include_both;
+  if (strstr (qname, ".in-addr.arpa") != NULL)
+    return response_ptr_v4 (ctx, b, qname, qclass, qtype);
+  else if (strstr (qname, ".ip6.arpa") != NULL)
+    return response_ptr_v6 (ctx, b, qname, qclass, qtype);
+
+  bool include_a = false;
+  bool include_aaaa = false;
+  bool include_match = false;
+  bool include_ptr = false;
+  for (const char *p = qname; *p != '.' && *p != '\0'; ++p)
+    {
+      if (*p == 'a')
+        include_a = true;
+      else if (*p == 'q')
+        include_aaaa = true;
+      else if (*p == 'm')
+        include_match = true;
+      else if (*p == 'p')
+        include_ptr = true;
+      else if (*p == '6' && qtype == T_AAAA)
+        break;
+    }
+  if (include_match)
+    {
+      if (qtype == T_A)
+        include_aaaa = false;
+      else if (qtype == T_AAAA)
+        include_a = false;
+    }
 
   resolv_response_init (b, (struct resolv_response_flags) {});
   resolv_response_add_question (b, qname, qclass, qtype);
@@ -44,11 +144,17 @@ response (const struct resolv_response_context *ctx,
     }
   if (include_aaaa)
     {
-        char ipv6[16]
-          = {0x20, 0x01, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
-        resolv_response_open_record (b, qname, qclass, T_AAAA, 0);
-        resolv_response_add_data (b, &ipv6, sizeof (ipv6));
-        resolv_response_close_record (b);
+      char ipv6[16]
+        = {0x20, 0x01, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
+      resolv_response_open_record (b, qname, qclass, T_AAAA, 0);
+      resolv_response_add_data (b, &ipv6, sizeof (ipv6));
+      resolv_response_close_record (b);
+    }
+  if (include_ptr)
+    {
+      resolv_response_open_record (b, qname, qclass, T_PTR, 0);
+      resolv_response_add_name (b, "ptr-target.example");
+      resolv_response_close_record (b);
     }
 }
 
@@ -64,16 +170,21 @@ test_gai (void)
         .ai_protocol = IPPROTO_TCP,
       };
     struct addrinfo *ai;
-    int ret = getaddrinfo ("www1.example", "80", &hints, &ai);
-    check_addrinfo ("getaddrinfo AF_UNSPEC www1.example", ai, ret,
+    int ret = getaddrinfo ("qam.example", "80", &hints, &ai);
+    check_addrinfo ("getaddrinfo AF_UNSPEC qam.example", ai, ret,
                     "address: STREAM/TCP 192.0.2.17 80\n"
                     "address: STREAM/TCP 2001:db8::1 80\n");
     if (ret == 0)
       freeaddrinfo (ai);
-    ret = getaddrinfo ("both.example", "80", &hints, &ai);
+    ret = getaddrinfo ("am.example", "80", &hints, &ai);
+    check_addrinfo ("getaddrinfo AF_UNSPEC am.example", ai, ret,
+                    "address: STREAM/TCP 192.0.2.17 80\n");
+    if (ret == 0)
+      freeaddrinfo (ai);
+    ret = getaddrinfo ("qa.example", "80", &hints, &ai);
     /* Combined A/AAAA responses currently result in address
        duplication.  */
-    check_addrinfo ("getaddrinfo AF_UNSPEC both.example", ai, ret,
+    check_addrinfo ("getaddrinfo AF_UNSPEC qa.example", ai, ret,
                     "address: STREAM/TCP 192.0.2.17 80\n"
                     "address: STREAM/TCP 192.0.2.17 80\n"
                     "address: STREAM/TCP 2001:db8::1 80\n"
@@ -89,13 +200,18 @@ test_gai (void)
         .ai_protocol = IPPROTO_TCP,
       };
     struct addrinfo *ai;
-    int ret = getaddrinfo ("www1.example", "80", &hints, &ai);
-    check_addrinfo ("getaddrinfo AF_INET www1.example", ai, ret,
+    int ret = getaddrinfo ("qam.example", "80", &hints, &ai);
+    check_addrinfo ("getaddrinfo AF_INET qam.example", ai, ret,
+                    "address: STREAM/TCP 192.0.2.17 80\n");
+    if (ret == 0)
+      freeaddrinfo (ai);
+    ret = getaddrinfo ("am.example", "80", &hints, &ai);
+    check_addrinfo ("getaddrinfo AF_INET am.example", ai, ret,
                     "address: STREAM/TCP 192.0.2.17 80\n");
     if (ret == 0)
       freeaddrinfo (ai);
-    ret = getaddrinfo ("both.example", "80", &hints, &ai);
-    check_addrinfo ("getaddrinfo AF_INET both.example", ai, ret,
+    ret = getaddrinfo ("qa.example", "80", &hints, &ai);
+    check_addrinfo ("getaddrinfo AF_INET qa.example", ai, ret,
                     "address: STREAM/TCP 192.0.2.17 80\n");
     if (ret == 0)
       freeaddrinfo (ai);
@@ -108,40 +224,196 @@ test_gai (void)
         .ai_protocol = IPPROTO_TCP,
       };
     struct addrinfo *ai;
-    int ret = getaddrinfo ("www1.example", "80", &hints, &ai);
+    int ret = getaddrinfo ("qa.example", "80", &hints, &ai);
     check_addrinfo ("getaddrinfo (AF_INET6)", ai, ret,
                     "address: STREAM/TCP 2001:db8::1 80\n");
     if (ret == 0)
       freeaddrinfo (ai);
-    ret = getaddrinfo ("both.example", "80", &hints, &ai);
-    check_addrinfo ("getaddrinfo AF_INET6 both.example", ai, ret,
+    ret = getaddrinfo ("am.example", "80", &hints, &ai);
+    check_addrinfo ("getaddrinfo AF_INET6 am.example", ai, ret,
+                    "error: No address associated with hostname\n");
+    if (ret == 0)
+      freeaddrinfo (ai);
+    ret = getaddrinfo ("qam.example", "80", &hints, &ai);
+    check_addrinfo ("getaddrinfo AF_INET6 qam.example", ai, ret,
                     "address: STREAM/TCP 2001:db8::1 80\n");
     if (ret == 0)
       freeaddrinfo (ai);
   }
 }
 
-/* Test that gethostbyname2 is not influenced by RES_USE_INET6.  */
+/* Test gethostbyaddr and getnameinfo.  The results are independent of
+   RES_USE_INET6.  */
 static void
-test_get2 (void)
+test_reverse (void)
 {
-  check_hostent ("gethostbyname2 AF_INET www1.example",
-                 gethostbyname2 ("www1.example", AF_INET),
-                 "name: www1.example\n"
+  {
+    char ipv4[4] = { 192, 0, 2, 17 };
+    check_hostent ("gethostbyaddr AF_INET",
+                   gethostbyaddr (ipv4, sizeof (ipv4), AF_INET),
+                   "name: 192-0-2-17.v4.example\n"
+                   "address: 192.0.2.17\n");
+  }
+  {
+    char ipv6[16]
+      = {0x20, 0x01, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
+    check_hostent ("gethostbyaddr AF_INET",
+                   gethostbyaddr (ipv6, sizeof (ipv6), AF_INET6),
+                   "name: 20010db8000000000000000000000001.v6.example\n"
+                   "address: 2001:db8::1\n");
+  }
+
+  {
+    struct sockaddr_in addr =
+      {
+        .sin_family = AF_INET,
+        .sin_addr = { .s_addr = htonl (0xc0000211) },
+        .sin_port = htons (80)
+      };
+    char host[NI_MAXHOST];
+    char service[NI_MAXSERV];
+    int ret = getnameinfo ((struct sockaddr *) &addr, sizeof (addr),
+                           host, sizeof (host), service, sizeof (service),
+                           NI_NUMERICSERV);
+    TEST_VERIFY (ret == 0);
+    TEST_VERIFY (strcmp (host, "192-0-2-17.v4.example") == 0);
+    TEST_VERIFY (strcmp (service, "80") == 0);
+  }
+  {
+    char ipv6[16]
+      = {0x20, 0x01, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
+    struct sockaddr_in6 addr =
+      {
+        .sin6_family = AF_INET6,
+        .sin6_port = htons (80),
+      };
+    TEST_VERIFY (sizeof (ipv6) == sizeof (addr.sin6_addr));
+    memcpy (&addr.sin6_addr, ipv6, sizeof (addr.sin6_addr));
+    char host[NI_MAXHOST];
+    char service[NI_MAXSERV];
+    int ret = getnameinfo ((struct sockaddr *) &addr, sizeof (addr),
+                           host, sizeof (host), service, sizeof (service),
+                           NI_NUMERICSERV);
+    TEST_VERIFY (ret == 0);
+    TEST_VERIFY
+      (strcmp (host, "20010db8000000000000000000000001.v6.example") == 0);
+    TEST_VERIFY (strcmp (service, "80") == 0);
+  }
+}
+
+/* Test that gethostbyname2 is mostly not influenced by
+   RES_USE_INET6.  */
+static void
+test_get2_any (void)
+{
+  check_hostent ("gethostbyname2 AF_INET am.example",
+                 gethostbyname2 ("am.example", AF_INET),
+                 "name: am.example\n"
+                 "address: 192.0.2.17\n");
+  check_hostent ("gethostbyname2 AF_INET a.example",
+                 gethostbyname2 ("a.example", AF_INET),
+                 "name: a.example\n"
                  "address: 192.0.2.17\n");
-  check_hostent ("gethostbyname2 AF_INET both.example",
-                 gethostbyname2 ("both.example", AF_INET),
-                 "name: both.example\n"
+  check_hostent ("gethostbyname2 AF_INET qm.example",
+                 gethostbyname2 ("qm.example", AF_INET),
+                 "error: NO_ADDRESS\n");
+  check_hostent ("gethostbyname2 AF_INET q.example",
+                 gethostbyname2 ("q.example", AF_INET),
+                 "error: NO_RECOVERY\n");
+  check_hostent ("gethostbyname2 AF_INET qam.example",
+                 gethostbyname2 ("qam.example", AF_INET),
+                 "name: qam.example\n"
+                 "address: 192.0.2.17\n");
+  check_hostent ("gethostbyname2 AF_INET qa.example",
+                 gethostbyname2 ("qa.example", AF_INET),
+                 "name: qa.example\n"
                  "address: 192.0.2.17\n");
 
-  check_hostent ("gethostbyname2 AF_INET6 www1.example",
-                 gethostbyname2 ("www1.example", AF_INET6),
-                 "name: www1.example\n"
+  check_hostent ("gethostbyname2 AF_INET6 qm.example",
+                 gethostbyname2 ("qm.example", AF_INET6),
+                 "name: qm.example\n"
+                 "address: 2001:db8::1\n");
+  check_hostent ("gethostbyname2 AF_INET6 q.example",
+                 gethostbyname2 ("q.example", AF_INET6),
+                 "name: q.example\n"
+                 "address: 2001:db8::1\n");
+  check_hostent ("gethostbyname2 AF_INET6 qam.example",
+                 gethostbyname2 ("qam.example", AF_INET6),
+                 "name: qam.example\n"
                  "address: 2001:db8::1\n");
-  check_hostent ("gethostbyname2 AF_INET6 both.example",
-                 gethostbyname2 ("both.example", AF_INET6),
-                 "name: both.example\n"
+  check_hostent ("gethostbyname2 AF_INET6 qa.example",
+                 gethostbyname2 ("qa.example", AF_INET6),
+                 "name: qa.example\n"
                  "address: 2001:db8::1\n");
+  /* Additional AF_INET6 tests depend on RES_USE_INET6; see below.  */
+
+  test_reverse ();
+}
+
+/* gethostbyname2 tests with RES_USE_INET6 disabled.  */
+static void
+test_get2_no_inet6 (void)
+{
+  test_get2_any ();
+
+  check_hostent ("gethostbyname2 AF_INET6 am.example",
+                 gethostbyname2 ("am.example", AF_INET6),
+                 "error: NO_ADDRESS\n");
+  check_hostent ("gethostbyname2 AF_INET6 a.example",
+                 gethostbyname2 ("a.example", AF_INET6),
+                 "error: NO_RECOVERY\n");
+}
+
+/* gethostbyname2 tests with RES_USE_INET6 enabled.  */
+static void
+test_get2_inet6 (void)
+{
+  test_get2_any ();
+
+  check_hostent ("gethostbyname2 AF_INET6 am.example",
+                 gethostbyname2 ("am.example", AF_INET6),
+                 "name: am.example\n"
+                 "address: ::ffff:192.0.2.17\n");
+  check_hostent ("gethostbyname2 AF_INET6 a.example",
+                 gethostbyname2 ("a.example", AF_INET6),
+                 "error: NO_RECOVERY\n");
+}
+
+/* Collection of tests which assume no RES_USE_INET6 flag.  */
+static void
+test_no_inet6 (void)
+{
+  check_hostent ("gethostbyname (\"a.example\")",
+                 gethostbyname ("a.example"),
+                 "name: a.example\n"
+                 "address: 192.0.2.17\n");
+  check_hostent ("gethostbyname (\"qa.example\")",
+                 gethostbyname ("qa.example"),
+                 "name: qa.example\n"
+                 "address: 192.0.2.17\n");
+  check_hostent ("gethostbyname (\"am.example\")",
+                 gethostbyname ("am.example"),
+                 "name: am.example\n"
+                 "address: 192.0.2.17\n");
+  check_hostent ("gethostbyname (\"amp.example\")",
+                 gethostbyname ("amp.example"),
+                 "name: amp.example\n"
+                 "address: 192.0.2.17\n");
+  check_hostent ("gethostbyname (\"qam.example\")",
+                 gethostbyname ("qam.example"),
+                 "name: qam.example\n"
+                 "address: 192.0.2.17\n");
+  check_hostent ("gethostbyname (\"q.example\")",
+                 gethostbyname ("q.example"),
+                 "error: NO_RECOVERY\n");
+  check_hostent ("gethostbyname (\"qm.example\")",
+                 gethostbyname ("qm.example"),
+                 "error: NO_ADDRESS\n");
+  test_get2_no_inet6 ();
+  test_get2_no_inet6 ();
+  test_gai ();
+  test_get2_no_inet6 ();
+  test_get2_no_inet6 ();
 }
 
 static void *
@@ -153,28 +425,64 @@ threadfunc (void *ignored)
        .response_callback = response
      });
 
-  check_hostent ("gethostbyname (\"www1.example\")",
-                 gethostbyname ("www1.example"),
-                 "name: www1.example\n"
-                 "address: 192.0.2.17\n");
-  check_hostent ("gethostbyname (\"both.example\")",
-                 gethostbyname ("both.example"),
-                 "name: both.example\n"
-                 "address: 192.0.2.17\n");
-  test_get2 ();
-  test_gai ();
+  TEST_VERIFY ((_res.options & RES_USE_INET6) == 0);
+  test_no_inet6 ();
 
   _res.options |= RES_USE_INET6;
-  check_hostent ("gethostbyname (\"www1.example\")",
-                 gethostbyname ("www1.example"),
-                 "name: www1.example\n"
+  check_hostent ("gethostbyname (\"a.inet6.example\")",
+                 gethostbyname ("a.inet6.example"),
+                 "error: NO_RECOVERY\n");
+  check_hostent ("gethostbyname (\"am.inet6.example\")",
+                 gethostbyname ("am.inet6.example"),
+                 "name: am.inet6.example\n"
+                 "address: ::ffff:192.0.2.17\n");
+  check_hostent ("gethostbyname (\"qa.inet6.example\")",
+                 gethostbyname ("qa.inet6.example"),
+                 "name: qa.inet6.example\n"
                  "address: 2001:db8::1\n");
-  check_hostent ("gethostbyname (\"both.example\")",
-                 gethostbyname ("both.example"),
-                 "name: both.example\n"
+  check_hostent ("gethostbyname (\"qam.inet6.example\")",
+                 gethostbyname ("qam.inet6.example"),
+                 "name: qam.inet6.example\n"
                  "address: 2001:db8::1\n");
-  test_get2 ();
+  check_hostent ("gethostbyname (\"q.inet6.example\")",
+                 gethostbyname ("q.inet6.example"),
+                 "name: q.inet6.example\n"
+                 "address: 2001:db8::1\n");
+  check_hostent ("gethostbyname (\"qm.inet6.example\")",
+                 gethostbyname ("qm.inet6.example"),
+                 "name: qm.inet6.example\n"
+                 "address: 2001:db8::1\n");
+  check_hostent ("gethostbyname (\"amp.inet6.example\")",
+                 gethostbyname ("amp.inet6.example"),
+                 "error: NO_RECOVERY\n");
+  check_hostent ("gethostbyname (\"qmp.inet6.example\")",
+                 gethostbyname ("qmp.inet6.example"),
+                 "name: qmp.inet6.example\n"
+                 "address: 2001:db8::1\n");
+  check_hostent ("gethostbyname (\"ap.inet6.example\")",
+                 gethostbyname ("ap.inet6.example"),
+                 "error: NO_RECOVERY\n");
+  check_hostent ("gethostbyname (\"6ap.inet6.example\")",
+                 gethostbyname ("6ap.inet6.example"),
+                 "name: 6ap.inet6.example\n"
+                 "address: ::ffff:192.0.2.17\n");
+  check_hostent ("gethostbyname (\"am6p.inet6.example\")",
+                 gethostbyname ("am6p.inet6.example"),
+                 "name: am6p.inet6.example\n"
+                 "address: ::ffff:192.0.2.17\n");
+  check_hostent ("gethostbyname (\"qp.inet6.example\")",
+                 gethostbyname ("qp.inet6.example"),
+                 "name: qp.inet6.example\n"
+                 "address: 2001:db8::1\n");
+  test_get2_inet6 ();
+  test_get2_inet6 ();
   test_gai ();
+  test_get2_inet6 ();
+  test_get2_inet6 ();
+
+  TEST_VERIFY (_res.options & RES_USE_INET6);
+  _res.options &= ~RES_USE_INET6;
+  test_no_inet6 ();
 
   resolv_test_end (obj);
 
diff --git a/resolv/tst-resolv-basic.c b/resolv/tst-resolv-basic.c
index 64eedbbd81..66a0e8a165 100644
--- a/resolv/tst-resolv-basic.c
+++ b/resolv/tst-resolv-basic.c
@@ -50,7 +50,7 @@ response (const struct resolv_response_context *ctx,
     qname_compare = qname + 2;
   else
     qname_compare = qname;
-  enum {www, alias, nxdomain, long_name} requested_qname;
+  enum {www, alias, nxdomain, long_name, nodata} requested_qname;
   if (strcmp (qname_compare, "www.example") == 0)
     requested_qname = www;
   else if (strcmp (qname_compare, "alias.example") == 0)
@@ -59,6 +59,8 @@ response (const struct resolv_response_context *ctx,
     requested_qname = nxdomain;
   else if (strcmp (qname_compare, LONG_NAME) == 0)
     requested_qname = long_name;
+  else if (strcmp (qname_compare, "nodata.example") == 0)
+    requested_qname = nodata;
   else
     {
       support_record_failure ();
@@ -87,6 +89,8 @@ response (const struct resolv_response_context *ctx,
       resolv_response_close_record (b);
       resolv_response_open_record (b, "www.example", qclass, qtype, 0);
       break;
+    case nodata:
+      return;
     case nxdomain:
       FAIL_EXIT1 ("unreachable");
     }
@@ -267,6 +271,55 @@ test_bug_21295 (void)
     }
 }
 
+/* Run tests which do not expect any data.  */
+static void
+test_nodata_nxdomain (void)
+{
+  /* Iterate through different address families.  */
+  int families[] = { AF_UNSPEC, AF_INET, AF_INET6, -1 };
+  for (int i = 0; families[i] >= 0; ++i)
+    /* If do_tcp, prepend "t." to the name to trigger TCP
+       fallback.  */
+    for (int do_tcp = 0; do_tcp < 2; ++do_tcp)
+      /* If do_nxdomain, trigger an NXDOMAIN error (DNS failure),
+         otherwise use a NODATA response (empty but successful
+         answer).  */
+      for (int do_nxdomain = 0; do_nxdomain < 2; ++do_nxdomain)
+        {
+          int family = families[i];
+          char *name = xasprintf ("%s%s.example",
+                                  do_tcp ? "t." : "",
+                                  do_nxdomain ? "nxdomain" : "nodata");
+
+          if (family != AF_UNSPEC)
+            {
+              if (do_nxdomain)
+                check_h (name, family, "error: HOST_NOT_FOUND\n");
+              else
+                check_h (name, family, "error: NO_ADDRESS\n");
+            }
+
+          const char *expected;
+          if (do_nxdomain)
+            expected = "error: Name or service not known\n";
+          else
+            expected = "error: No address associated with hostname\n";
+
+          check_ai (name, "80", family, expected);
+
+          struct addrinfo hints =
+            {
+              .ai_family = family,
+              .ai_flags = AI_V4MAPPED | AI_ALL,
+            };
+          check_ai_hints (name, "80", hints, expected);
+          hints.ai_flags |= AI_CANONNAME;
+          check_ai_hints (name, "80", hints, expected);
+
+          free (name);
+        }
+}
+
 static int
 do_test (void)
 {
@@ -439,29 +492,8 @@ do_test (void)
             "address: DGRAM/UDP 2001:db8::4 80\n"
             "address: RAW/IP 2001:db8::4 80\n");
 
-  check_h ("nxdomain.example", AF_INET,
-           "error: HOST_NOT_FOUND\n");
-  check_h ("nxdomain.example", AF_INET6,
-           "error: HOST_NOT_FOUND\n");
-  check_ai ("nxdomain.example", "80", AF_UNSPEC,
-            "error: Name or service not known\n");
-  check_ai ("nxdomain.example", "80", AF_INET,
-            "error: Name or service not known\n");
-  check_ai ("nxdomain.example", "80", AF_INET6,
-            "error: Name or service not known\n");
-
-  check_h ("t.nxdomain.example", AF_INET,
-           "error: HOST_NOT_FOUND\n");
-  check_h ("t.nxdomain.example", AF_INET6,
-           "error: HOST_NOT_FOUND\n");
-  check_ai ("t.nxdomain.example", "80", AF_UNSPEC,
-            "error: Name or service not known\n");
-  check_ai ("t.nxdomain.example", "80", AF_INET,
-            "error: Name or service not known\n");
-  check_ai ("t.nxdomain.example", "80", AF_INET6,
-            "error: Name or service not known\n");
-
   test_bug_21295 ();
+  test_nodata_nxdomain ();
 
   resolv_test_end (aux);
 
diff --git a/resolv/tst-resolv-qtypes.c b/resolv/tst-resolv-qtypes.c
index 06ea3dbd14..da3325f80c 100644
--- a/resolv/tst-resolv-qtypes.c
+++ b/resolv/tst-resolv-qtypes.c
@@ -50,7 +50,7 @@ response (const struct resolv_response_context *ctx,
   resolv_response_close_record (b);
 }
 
-static const char * const domain = "www.example.com";
+static const char domain[] = "www.example.com";
 
 static int
 wrap_res_query (int type, unsigned char *answer, int answer_length)
diff --git a/stdlib/getentropy.c b/stdlib/getentropy.c
index a71d4cd8f5..a88bbf8de3 100644
--- a/stdlib/getentropy.c
+++ b/stdlib/getentropy.c
@@ -21,7 +21,7 @@
 
 /* Write LENGTH bytes of randomness starting at BUFFER.  Return 0 on
    success and -1 on failure.  */
-ssize_t
+int
 getentropy (void *buffer, size_t length)
 {
   __set_errno (ENOSYS);
diff --git a/string/stratcliff.c b/string/stratcliff.c
index e28b0c5058..4320336c9a 100644
--- a/string/stratcliff.c
+++ b/string/stratcliff.c
@@ -58,8 +58,8 @@
 int
 do_test (void)
 {
-  int size = sysconf (_SC_PAGESIZE);
-  int nchars = size / sizeof (CHAR);
+  size_t size = sysconf (_SC_PAGESIZE);
+  size_t nchars = size / sizeof (CHAR);
   CHAR *adr;
   CHAR *dest;
   int result = 0;
@@ -80,7 +80,17 @@ do_test (void)
     }
   else
     {
-      int inner, middle, outer;
+      size_t inner, middle, outer, nchars64, max128;
+
+      if (nchars > 64)
+	nchars64 = nchars - 64;
+      else
+	nchars64 = 0;
+
+      if (nchars > 128)
+	max128 = nchars - 128;
+      else
+	max128 = 0;
 
       mprotect (adr, size, PROT_NONE);
       mprotect (adr + 2 * nchars, size, PROT_NONE);
@@ -93,59 +103,65 @@ do_test (void)
       MEMSET (adr, L('T'), nchars);
 
       /* strlen/wcslen test */
-      for (outer = nchars - 1; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars - 1; outer >= max128; --outer)
 	{
-	  for (inner = MAX (outer, nchars - 64); inner < nchars; ++inner)
+	  for (inner = MAX (outer, nchars64); inner < nchars; ++inner)
 	    {
 	      adr[inner] = L('\0');
 
 	      if (STRLEN (&adr[outer]) != (size_t) (inner - outer))
 		{
-		  printf ("%s flunked for outer = %d, inner = %d\n",
+		  printf ("%s flunked for outer = %zu, inner = %zu\n",
 			  STRINGIFY (STRLEN), outer, inner);
 		  result = 1;
 		}
 
 	      adr[inner] = L('T');
 	    }
+	  if (outer == 0)
+	    break;
 	}
 
       /* strnlen/wcsnlen test */
-      for (outer = nchars; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars; outer >= max128; --outer)
 	{
-	  for (inner = MAX (outer, nchars - 64); inner < nchars; ++inner)
+	  for (inner = MAX (outer, nchars64); inner < nchars; ++inner)
 	    {
 	      adr[inner] = L('\0');
 
 	      if (STRNLEN (&adr[outer], inner - outer + 1)
 		  != (size_t) (inner - outer))
 		{
-		  printf ("%s flunked for outer = %d, inner = %d\n",
+		  printf ("%s flunked for outer = %zu, inner = %zu\n",
 			  STRINGIFY (STRNLEN), outer, inner);
 		  result = 1;
 		}
 
 	      adr[inner] = L('T');
 	    }
+	  if (outer == 0)
+	    break;
 	}
-      for (outer = nchars; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars; outer >= max128; --outer)
 	{
-	  for (inner = MAX (outer, nchars - 64); inner <= nchars; ++inner)
+	  for (inner = MAX (outer, nchars64); inner <= nchars; ++inner)
 	    {
 	      if (STRNLEN (&adr[outer], inner - outer)
 		  != (size_t) (inner - outer))
 		{
-		  printf ("%s flunked bounded for outer = %d, inner = %d\n",
+		  printf ("%s flunked bounded for outer = %zu, inner = %zu\n",
 			  STRINGIFY (STRNLEN), outer, inner);
 		  result = 1;
 		}
 	    }
+	  if (outer == 0)
+	    break;
 	}
 
       /* strchr/wcschr test */
-      for (outer = nchars - 1; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars - 1; outer >= max128; --outer)
 	{
-	  for (middle = MAX (outer, nchars - 64); middle < nchars; ++middle)
+	  for (middle = MAX (outer, nchars64); middle < nchars; ++middle)
 	    {
 	      for (inner = middle; inner < nchars; ++inner)
 		{
@@ -158,8 +174,8 @@ do_test (void)
 		      || (inner != middle
 			  && (cp - &adr[outer]) != middle - outer))
 		    {
-		      printf ("%s flunked for outer = %d, middle = %d, "
-			      "inner = %d\n",
+		      printf ("%s flunked for outer = %zu, middle = %zu, "
+			      "inner = %zu\n",
 			      STRINGIFY (STRCHR), outer, middle, inner);
 		      result = 1;
 		    }
@@ -168,6 +184,8 @@ do_test (void)
 		  adr[middle] = L('T');
 		}
 	    }
+	  if (outer == 0)
+	    break;
 	}
 
       /* Special test.  */
@@ -180,9 +198,9 @@ do_test (void)
 	}
 
       /* strrchr/wcsrchr test */
-      for (outer = nchars - 1; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars - 1; outer >= max128; --outer)
 	{
-	  for (middle = MAX (outer, nchars - 64); middle < nchars; ++middle)
+	  for (middle = MAX (outer, nchars64); middle < nchars; ++middle)
 	    {
 	      for (inner = middle; inner < nchars; ++inner)
 		{
@@ -195,8 +213,8 @@ do_test (void)
 		      || (inner != middle
 			  && (cp - &adr[outer]) != middle - outer))
 		    {
-		      printf ("%s flunked for outer = %d, middle = %d, "
-			      "inner = %d\n",
+		      printf ("%s flunked for outer = %zu, middle = %zu, "
+			      "inner = %zu\n",
 			      STRINGIFY (STRRCHR), outer, middle, inner);
 		      result = 1;
 		    }
@@ -205,12 +223,14 @@ do_test (void)
 		  adr[middle] = L('T');
 		}
 	    }
+	  if (outer == 0)
+	    break;
 	}
 
       /* memchr test */
-      for (outer = nchars - 1; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars - 1; outer >= max128; --outer)
 	{
-	  for (middle = MAX (outer, nchars - 64); middle < nchars; ++middle)
+	  for (middle = MAX (outer, nchars64); middle < nchars; ++middle)
 	    {
 	      adr[middle] = L('V');
 
@@ -218,32 +238,36 @@ do_test (void)
 
 	      if (cp - &adr[outer] != middle - outer)
 		{
-		  printf ("%s flunked for outer = %d, middle = %d\n",
+		  printf ("%s flunked for outer = %zu, middle = %zu\n",
 			  STRINGIFY (MEMCHR), outer, middle);
 		  result = 1;
 		}
 
 	      adr[middle] = L('T');
 	    }
+	  if (outer == 0)
+	    break;
 	}
-      for (outer = nchars; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars; outer >= max128; --outer)
 	{
 	  CHAR *cp = MEMCHR (&adr[outer], L('V'), nchars - outer);
 
 	  if (cp != NULL)
 	    {
-	      printf ("%s flunked for outer = %d\n",
+	      printf ("%s flunked for outer = %zu\n",
 		      STRINGIFY (MEMCHR), outer);
 	      result = 1;
 	    }
+	  if (outer == 0)
+	    break;
 	}
 
       /* These functions only exist for single-byte characters.  */
 #ifndef WCSTEST
       /* rawmemchr test */
-      for (outer = nchars - 1; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars - 1; outer >= max128; --outer)
 	{
-	  for (middle = MAX (outer, nchars - 64); middle < nchars; ++middle)
+	  for (middle = MAX (outer, nchars64); middle < nchars; ++middle)
 	    {
 	      adr[middle] = L('V');
 
@@ -251,19 +275,21 @@ do_test (void)
 
 	      if (cp - &adr[outer] != middle - outer)
 		{
-		  printf ("%s flunked for outer = %d, middle = %d\n",
+		  printf ("%s flunked for outer = %zu, middle = %zu\n",
 			  STRINGIFY (rawmemchr), outer, middle);
 		  result = 1;
 		}
 
 	      adr[middle] = L('T');
 	    }
+	  if (outer == 0)
+	    break;
 	}
 
       /* memrchr test */
-      for (outer = nchars - 1; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars - 1; outer >= max128; --outer)
 	{
-	  for (middle = MAX (outer, nchars - 64); middle < nchars; ++middle)
+	  for (middle = MAX (outer, nchars64); middle < nchars; ++middle)
 	    {
 	      adr[middle] = L('V');
 
@@ -271,44 +297,50 @@ do_test (void)
 
 	      if (cp - &adr[outer] != middle - outer)
 		{
-		  printf ("%s flunked for outer = %d, middle = %d\n",
+		  printf ("%s flunked for outer = %zu, middle = %zu\n",
 			  STRINGIFY (memrchr), outer, middle);
 		  result = 1;
 		}
 
 	      adr[middle] = L('T');
 	    }
+	  if (outer == 0)
+	    break;
 	}
-      for (outer = nchars; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars; outer >= max128; --outer)
 	{
 	  CHAR *cp = memrchr (&adr[outer], L('V'), nchars - outer);
 
 	  if (cp != NULL)
 	    {
-	      printf ("%s flunked for outer = %d\n",
+	      printf ("%s flunked for outer = %zu\n",
 		      STRINGIFY (memrchr), outer);
 	      result = 1;
 	    }
+	  if (outer == 0)
+	    break;
 	}
 #endif
 
       /* strcpy/wcscpy test */
-      for (outer = nchars - 1; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars - 1; outer >= max128; --outer)
 	{
-	  for (inner = MAX (outer, nchars - 64); inner < nchars; ++inner)
+	  for (inner = MAX (outer, nchars64); inner < nchars; ++inner)
 	    {
 	      adr[inner] = L('\0');
 
 	      if (STRCPY (dest, &adr[outer]) != dest
 		  || STRLEN (dest) != (size_t) (inner - outer))
 		{
-		  printf ("%s flunked for outer = %d, inner = %d\n",
+		  printf ("%s flunked for outer = %zu, inner = %zu\n",
 			  STRINGIFY (STRCPY), outer, inner);
 		  result = 1;
 		}
 
 	      adr[inner] = L('T');
 	    }
+	  if (outer == 0)
+	    break;
 	}
 
       /* strcmp/wcscmp tests */
@@ -322,14 +354,14 @@ do_test (void)
 
 	    if (STRCMP (adr + middle, dest + nchars - outer) <= 0)
 	      {
-		printf ("%s 1 flunked for outer = %d, middle = %d\n",
+		printf ("%s 1 flunked for outer = %zu, middle = %zu\n",
 			STRINGIFY (STRCMP), outer, middle);
 		result = 1;
 	      }
 
 	    if (STRCMP (dest + nchars - outer, adr + middle) >= 0)
 	      {
-		printf ("%s 2 flunked for outer = %d, middle = %d\n",
+		printf ("%s 2 flunked for outer = %zu, middle = %zu\n",
 			STRINGIFY (STRCMP), outer, middle);
 		result = 1;
 	      }
@@ -348,16 +380,16 @@ do_test (void)
 	      {
 		if (STRNCMP (adr + middle, dest + nchars - outer, inner) != 0)
 		  {
-		    printf ("%s 1 flunked for outer = %d, middle = %d, "
-			    "inner = %d\n",
+		    printf ("%s 1 flunked for outer = %zu, middle = %zu, "
+			    "inner = %zu\n",
 			    STRINGIFY (STRNCMP), outer, middle, inner);
 		    result = 1;
 		  }
 
 		if (STRNCMP (dest + nchars - outer, adr + middle, inner) != 0)
 		  {
-		    printf ("%s 2 flunked for outer = %d, middle = %d, "
-			    "inner = %d\n",
+		    printf ("%s 2 flunked for outer = %zu, middle = %zu, "
+			    "inner = %zu\n",
 			    STRINGIFY (STRNCMP), outer, middle, inner);
 		    result = 1;
 		  }
@@ -365,14 +397,14 @@ do_test (void)
 
 	    if (STRNCMP (adr + middle, dest + nchars - outer, outer) >= 0)
 	      {
-		printf ("%s 1 flunked for outer = %d, middle = %d, full\n",
+		printf ("%s 1 flunked for outer = %zu, middle = %zu, full\n",
 			STRINGIFY (STRNCMP), outer, middle);
 		result = 1;
 	      }
 
 	    if (STRNCMP (dest + nchars - outer, adr + middle, outer) <= 0)
 	      {
-		printf ("%s 2 flunked for outer = %d, middle = %d, full\n",
+		printf ("%s 2 flunked for outer = %zu, middle = %zu, full\n",
 			STRINGIFY (STRNCMP), outer, middle);
 		result = 1;
 	      }
@@ -380,7 +412,7 @@ do_test (void)
 
       /* strncpy/wcsncpy tests */
       adr[nchars - 1] = L('T');
-      for (outer = nchars; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars; outer >= max128; --outer)
 	{
 	  size_t len;
 
@@ -389,17 +421,19 @@ do_test (void)
 	      if (STRNCPY (dest, &adr[outer], len) != dest
 		  || MEMCMP (dest, &adr[outer], len) != 0)
 		{
-		  printf ("outer %s flunked for outer = %d, len = %Zd\n",
+		  printf ("outer %s flunked for outer = %zu, len = %zu\n",
 			  STRINGIFY (STRNCPY), outer, len);
 		  result = 1;
 		}
 	    }
+	  if (outer == 0)
+	    break;
 	}
       adr[nchars - 1] = L('\0');
 
-      for (outer = nchars - 1; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars - 1; outer >= max128; --outer)
 	{
-	  for (inner = MAX (outer, nchars - 64); inner < nchars; ++inner)
+	  for (inner = MAX (outer, nchars64); inner < nchars; ++inner)
 	    {
 	      size_t len;
 
@@ -413,8 +447,8 @@ do_test (void)
 		      || (inner - outer < len
 			  && STRLEN (dest) != (inner - outer)))
 		    {
-		      printf ("%s flunked for outer = %d, inner = %d, "
-			      "len = %Zd\n",
+		      printf ("%s flunked for outer = %zu, inner = %zu, "
+			      "len = %zu\n",
 			      STRINGIFY (STRNCPY), outer, inner, len);
 		      result = 1;
 		    }
@@ -424,8 +458,8 @@ do_test (void)
 		      || (inner - outer < len
 			  && STRLEN (dest + 1) != (inner - outer)))
 		    {
-		      printf ("%s+1 flunked for outer = %d, inner = %d, "
-			      "len = %Zd\n",
+		      printf ("%s+1 flunked for outer = %zu, inner = %zu, "
+			      "len = %zu\n",
 			      STRINGIFY (STRNCPY), outer, inner, len);
 		      result = 1;
 		    }
@@ -433,29 +467,33 @@ do_test (void)
 
 	      adr[inner] = L('T');
 	    }
+	  if (outer == 0)
+	    break;
 	}
 
       /* stpcpy/wcpcpy test */
-      for (outer = nchars - 1; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars - 1; outer >= max128; --outer)
 	{
-	  for (inner = MAX (outer, nchars - 64); inner < nchars; ++inner)
+	  for (inner = MAX (outer, nchars64); inner < nchars; ++inner)
 	    {
 	      adr[inner] = L('\0');
 
 	      if ((STPCPY (dest, &adr[outer]) - dest) != inner - outer)
 		{
-		  printf ("%s flunked for outer = %d, inner = %d\n",
+		  printf ("%s flunked for outer = %zu, inner = %zu\n",
 			  STRINGIFY (STPCPY), outer, inner);
 		  result = 1;
 		}
 
 	      adr[inner] = L('T');
 	    }
+	  if (outer == 0)
+	    break;
 	}
 
       /* stpncpy/wcpncpy test */
       adr[nchars - 1] = L('T');
-      for (outer = nchars; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars; outer >= max128; --outer)
 	{
 	  size_t len;
 
@@ -464,17 +502,19 @@ do_test (void)
 	      if (STPNCPY (dest, &adr[outer], len) != dest + len
 		  || MEMCMP (dest, &adr[outer], len) != 0)
 		{
-		  printf ("outer %s flunked for outer = %d, len = %Zd\n",
+		  printf ("outer %s flunked for outer = %zu, len = %zu\n",
 			  STRINGIFY (STPNCPY), outer, len);
 		  result = 1;
 		}
 	    }
+	  if (outer == 0)
+	    break;
 	}
       adr[nchars - 1] = L('\0');
 
-      for (outer = nchars - 1; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars - 1; outer >= max128; --outer)
 	{
-	  for (middle = MAX (outer, nchars - 64); middle < nchars; ++middle)
+	  for (middle = MAX (outer, nchars64); middle < nchars; ++middle)
 	    {
 	      adr[middle] = L('\0');
 
@@ -483,8 +523,8 @@ do_test (void)
 		  if ((STPNCPY (dest, &adr[outer], inner) - dest)
 		      != MIN (inner, middle - outer))
 		    {
-		      printf ("%s flunked for outer = %d, middle = %d, "
-			      "inner = %d\n",
+		      printf ("%s flunked for outer = %zu, middle = %zu, "
+			      "inner = %zu\n",
 			      STRINGIFY (STPNCPY), outer, middle, inner);
 		      result = 1;
 		    }
@@ -492,66 +532,84 @@ do_test (void)
 
 	      adr[middle] = L('T');
 	    }
+	  if (outer == 0)
+	    break;
 	}
 
       /* memcpy/wmemcpy test */
-      for (outer = nchars; outer >= MAX (0, nchars - 128); --outer)
-	for (inner = 0; inner < nchars - outer; ++inner)
-	  if (MEMCPY (dest, &adr[outer], inner) !=  dest)
-	    {
-	      printf ("%s flunked for outer = %d, inner = %d\n",
-		      STRINGIFY (MEMCPY), outer, inner);
-	      result = 1;
-	    }
+      for (outer = nchars; outer >= max128; --outer)
+	{
+	  for (inner = 0; inner < nchars - outer; ++inner)
+	    if (MEMCPY (dest, &adr[outer], inner) !=  dest)
+	      {
+		printf ("%s flunked for outer = %zu, inner = %zu\n",
+			STRINGIFY (MEMCPY), outer, inner);
+		result = 1;
+	      }
+	  if (outer == 0)
+	    break;
+	}
 
       /* mempcpy/wmempcpy test */
-      for (outer = nchars; outer >= MAX (0, nchars - 128); --outer)
-	for (inner = 0; inner < nchars - outer; ++inner)
-	  if (MEMPCPY (dest, &adr[outer], inner) !=  dest + inner)
-	    {
-	      printf ("%s flunked for outer = %d, inner = %d\n",
-		      STRINGIFY (MEMPCPY), outer, inner);
-	      result = 1;
-	    }
+      for (outer = nchars; outer >= max128; --outer)
+	{
+	  for (inner = 0; inner < nchars - outer; ++inner)
+	    if (MEMPCPY (dest, &adr[outer], inner) !=  dest + inner)
+	      {
+		printf ("%s flunked for outer = %zu, inner = %zu\n",
+			STRINGIFY (MEMPCPY), outer, inner);
+		result = 1;
+	      }
+	  if (outer == 0)
+	    break;
+	}
 
       /* This function only exists for single-byte characters.  */
 #ifndef WCSTEST
       /* memccpy test */
       memset (adr, '\0', nchars);
-      for (outer = nchars; outer >= MAX (0, nchars - 128); --outer)
-	for (inner = 0; inner < nchars - outer; ++inner)
-	  if (memccpy (dest, &adr[outer], L('\1'), inner) != NULL)
-	    {
-	      printf ("memccpy flunked full copy for outer = %d, inner = %d\n",
-		      outer, inner);
-	      result = 1;
-	    }
-      for (outer = nchars - 1; outer >= MAX (0, nchars - 128); --outer)
-	for (middle = 0; middle < nchars - outer; ++middle)
-	  {
-	    memset (dest, L('\2'), middle + 1);
-	    for (inner = 0; inner < middle; ++inner)
+      for (outer = nchars; outer >= max128; --outer)
+	{
+	  for (inner = 0; inner < nchars - outer; ++inner)
+	    if (memccpy (dest, &adr[outer], L('\1'), inner) != NULL)
 	      {
-		adr[outer + inner] = L('\1');
-
-		if (memccpy (dest, &adr[outer], '\1', middle + 128)
-		    !=  dest + inner + 1)
-		  {
-		    printf ("\
-memccpy flunked partial copy for outer = %d, middle = %d, inner = %d\n",
-			    outer, middle, inner);
-		    result = 1;
-		  }
-		else if (dest[inner + 1] != L('\2'))
-		  {
-		    printf ("\
-memccpy copied too much for outer = %d, middle = %d, inner = %d\n",
-			    outer, middle, inner);
-		    result = 1;
-		  }
-		adr[outer + inner] = L('\0');
+		printf ("memccpy flunked full copy for outer = %zu, inner = %zu\n",
+			outer, inner);
+		result = 1;
 	      }
-	  }
+	  if (outer == 0)
+	    break;
+	}
+      for (outer = nchars - 1; outer >= max128; --outer)
+	{
+	  for (middle = 0; middle < nchars - outer; ++middle)
+	    {
+	      memset (dest, L('\2'), middle + 1);
+	      for (inner = 0; inner < middle; ++inner)
+		{
+		  adr[outer + inner] = L('\1');
+
+		  if (memccpy (dest, &adr[outer], '\1', middle + 128)
+		      !=  dest + inner + 1)
+		    {
+		      printf ("\
+			      memccpy flunked partial copy for outer = %zu, middle = %zu, inner = %zu\n",
+			      outer, middle, inner);
+		      result = 1;
+		    }
+		  else if (dest[inner + 1] != L('\2'))
+		    {
+		      printf ("\
+			      memccpy copied too much for outer = %zu, middle = %zu, inner = %zu\n",
+			      outer, middle, inner);
+		      result = 1;
+		    }
+		  adr[outer + inner] = L('\0');
+		}
+	    }
+	  if (outer == 0)
+	    break;
+	}
 #endif
     }
 
diff --git a/support/namespace.h b/support/namespace.h
index 859c2fda3f..9eddb1a0e9 100644
--- a/support/namespace.h
+++ b/support/namespace.h
@@ -66,7 +66,9 @@ struct support_chroot_configuration
 {
   /* File contents.  The files are not created if the field is
      NULL.  */
-  const char *resolv_conf;
+  const char *resolv_conf;      /* /etc/resolv.conf.  */
+  const char *hosts;            /* /etc/hosts.  */
+  const char *host_conf;        /* /etc/host.conf.  */
 };
 
 /* The result of the creation of a chroot.  */
@@ -78,8 +80,11 @@ struct support_chroot
   /* Path to the chroot directory.  */
   char *path_chroot;
 
-  /* Path to the /etc/resolv.conf file.  */
-  char *path_resolv_conf;
+  /* Paths to files in the chroot.  These are absolute and outside of
+     the chroot.  */
+  char *path_resolv_conf;       /* /etc/resolv.conf.  */
+  char *path_hosts;             /* /etc/hosts.  */
+  char *path_host_conf;         /* /etc/host.conf.  */
 };
 
 /* Create a chroot environment.  The returned data should be freed
diff --git a/support/support_chroot.c b/support/support_chroot.c
index c0807b313a..f3ef551b05 100644
--- a/support/support_chroot.c
+++ b/support/support_chroot.c
@@ -24,6 +24,23 @@
 #include <support/test-driver.h>
 #include <support/xunistd.h>
 
+/* If CONTENTS is not NULL, write it to the file at DIRECTORY/RELPATH,
+   and store the name in *ABSPATH.  If CONTENTS is NULL, store NULL in
+   *ABSPATH.  */
+static void
+write_file (const char *directory, const char *relpath, const char *contents,
+            char **abspath)
+{
+  if (contents != NULL)
+    {
+      *abspath = xasprintf ("%s/%s", directory, relpath);
+      add_temp_file (*abspath);
+      support_write_file_string (*abspath, contents);
+    }
+  else
+    *abspath = NULL;
+}
+
 struct support_chroot *
 support_chroot_create (struct support_chroot_configuration conf)
 {
@@ -39,15 +56,10 @@ support_chroot_create (struct support_chroot_configuration conf)
   xmkdir (path_etc, 0777);
   add_temp_file (path_etc);
 
-  if (conf.resolv_conf != NULL)
-    {
-      /* Create an empty resolv.conf file.  */
-      chroot->path_resolv_conf = xasprintf ("%s/resolv.conf", path_etc);
-      add_temp_file (chroot->path_resolv_conf);
-      support_write_file_string (chroot->path_resolv_conf, conf.resolv_conf);
-    }
-  else
-    chroot->path_resolv_conf = NULL;
+  write_file (path_etc, "resolv.conf", conf.resolv_conf,
+              &chroot->path_resolv_conf);
+  write_file (path_etc, "hosts", conf.hosts, &chroot->path_hosts);
+  write_file (path_etc, "host.conf", conf.host_conf, &chroot->path_host_conf);
 
   free (path_etc);
 
@@ -67,5 +79,7 @@ support_chroot_free (struct support_chroot *chroot)
 {
   free (chroot->path_chroot);
   free (chroot->path_resolv_conf);
+  free (chroot->path_hosts);
+  free (chroot->path_host_conf);
   free (chroot);
 }
diff --git a/sysdeps/i386/i686/fpu/multiarch/libm-test-ulps b/sysdeps/i386/i686/fpu/multiarch/libm-test-ulps
index 81dd1a09ea..053f5ec972 100644
--- a/sysdeps/i386/i686/fpu/multiarch/libm-test-ulps
+++ b/sysdeps/i386/i686/fpu/multiarch/libm-test-ulps
@@ -58,7 +58,7 @@ double: 1
 float128: 2
 idouble: 1
 ifloat128: 2
-ildouble: 4
+ildouble: 5
 ldouble: 3
 
 Function: "asin":
@@ -1154,8 +1154,8 @@ float128: 4
 idouble: 3
 ifloat: 3
 ifloat128: 4
-ildouble: 7
-ldouble: 7
+ildouble: 8
+ldouble: 8
 
 Function: Imaginary part of "clog10_upward":
 double: 1
@@ -2013,8 +2013,8 @@ double: 3
 float: 4
 idouble: 3
 ifloat: 4
-ildouble: 5
-ldouble: 5
+ildouble: 6
+ldouble: 6
 
 Function: "hypot":
 double: 1
@@ -2205,8 +2205,8 @@ float128: 8
 idouble: 3
 ifloat: 4
 ifloat128: 8
-ildouble: 5
-ldouble: 5
+ildouble: 6
+ldouble: 6
 
 Function: "log":
 double: 1
diff --git a/sysdeps/posix/getaddrinfo.c b/sysdeps/posix/getaddrinfo.c
index efa7118498..2c4b6d6793 100644
--- a/sysdeps/posix/getaddrinfo.c
+++ b/sysdeps/posix/getaddrinfo.c
@@ -241,46 +241,43 @@ convert_hostent_to_gaih_addrtuple (const struct addrinfo *req,
 
 #define gethosts(_family, _type) \
  {									      \
-  int herrno;								      \
   struct hostent th;							      \
-  struct hostent *h;							      \
   char *localcanon = NULL;						      \
   no_data = 0;								      \
-  while (1) {								      \
-    rc = 0;								      \
-    status = DL_CALL_FCT (fct, (name, _family, &th,			      \
-				tmpbuf->data, tmpbuf->length,		      \
-				&rc, &herrno, NULL, &localcanon));	      \
-    if (rc != ERANGE || herrno != NETDB_INTERNAL)			      \
-      break;								      \
-    if (!scratch_buffer_grow (tmpbuf))					      \
-      {									      \
-	result = -EAI_MEMORY;						      \
-	goto free_and_return;						      \
-      }									      \
-  }									      \
-  if (status == NSS_STATUS_SUCCESS && rc == 0)				      \
-    h = &th;								      \
-  else									      \
-    h = NULL;								      \
-  if (rc != 0)								      \
+  while (1)								      \
     {									      \
-      if (herrno == NETDB_INTERNAL)					      \
+      status = DL_CALL_FCT (fct, (name, _family, &th,			      \
+				  tmpbuf->data, tmpbuf->length,		      \
+				  &errno, &h_errno, NULL, &localcanon));      \
+      if (status != NSS_STATUS_TRYAGAIN || h_errno != NETDB_INTERNAL	      \
+	  || errno != ERANGE)						      \
+	break;								      \
+      if (!scratch_buffer_grow (tmpbuf))				      \
+	{								      \
+	  __resolv_context_enable_inet6 (res_ctx, res_enable_inet6);	      \
+	  __resolv_context_put (res_ctx);				      \
+	  result = -EAI_MEMORY;						      \
+	  goto free_and_return;						      \
+	}								      \
+    }									      \
+  if (status == NSS_STATUS_NOTFOUND					      \
+      || status == NSS_STATUS_TRYAGAIN || status == NSS_STATUS_UNAVAIL)	      \
+    {									      \
+      if (h_errno == NETDB_INTERNAL)					      \
 	{								      \
-	  __set_h_errno (herrno);					      \
 	  __resolv_context_enable_inet6 (res_ctx, res_enable_inet6);	      \
 	  __resolv_context_put (res_ctx);				      \
 	  result = -EAI_SYSTEM;						      \
 	  goto free_and_return;						      \
 	}								      \
-      if (herrno == TRY_AGAIN)						      \
+      if (h_errno == TRY_AGAIN)						      \
 	no_data = EAI_AGAIN;						      \
       else								      \
-	no_data = herrno == NO_DATA;					      \
+	no_data = h_errno == NO_DATA;					      \
     }									      \
-  else if (h != NULL)							      \
+  else if (status == NSS_STATUS_SUCCESS)				      \
     {									      \
-      if (!convert_hostent_to_gaih_addrtuple (req, _family,h, &addrmem))      \
+      if (!convert_hostent_to_gaih_addrtuple (req, _family, &th, &addrmem))   \
 	{								      \
 	  __resolv_context_enable_inet6 (res_ctx, res_enable_inet6);	      \
 	  __resolv_context_put (res_ctx);				      \
@@ -332,10 +329,8 @@ getcanonname (service_user *nip, struct gaih_addrtuple *at, const char *name)
   if (cfct != NULL)
     {
       char buf[256];
-      int herrno;
-      int rc;
       if (DL_CALL_FCT (cfct, (at->name ?: name, buf, sizeof (buf),
-			      &s, &rc, &herrno)) != NSS_STATUS_SUCCESS)
+			      &s, &errno, &h_errno)) != NSS_STATUS_SUCCESS)
 	/* If the canonical name cannot be determined, use the passed
 	   string.  */
 	s = (char *) name;
@@ -351,7 +346,6 @@ gaih_inet (const char *name, const struct gaih_service *service,
   const struct gaih_typeproto *tp = gaih_inet_typeproto;
   struct gaih_servtuple *st = (struct gaih_servtuple *) &nullserv;
   struct gaih_addrtuple *at = NULL;
-  int rc;
   bool got_ipv6 = false;
   const char *canon = NULL;
   const char *orig_name = name;
@@ -393,7 +387,8 @@ gaih_inet (const char *name, const struct gaih_service *service,
 	      st = (struct gaih_servtuple *)
 		alloca_account (sizeof (struct gaih_servtuple), alloca_used);
 
-	      if ((rc = gaih_inet_serv (service->name, tp, req, st, tmpbuf)))
+	      int rc = gaih_inet_serv (service->name, tp, req, st, tmpbuf);
+	      if (__glibc_unlikely (rc != 0))
 		return rc;
 	    }
 	  else
@@ -418,13 +413,9 @@ gaih_inet (const char *name, const struct gaih_service *service,
 		    alloca_account (sizeof (struct gaih_servtuple),
 				    alloca_used);
 
-		  if ((rc = gaih_inet_serv (service->name,
-					    tp, req, newp, tmpbuf)))
-		    {
-		      if (rc)
-			continue;
-		      return rc;
-		    }
+		  if (gaih_inet_serv (service->name,
+				      tp, req, newp, tmpbuf) != 0)
+		    continue;
 
 		  *pst = newp;
 		  pst = &(newp->next);
@@ -497,7 +488,7 @@ gaih_inet (const char *name, const struct gaih_service *service,
 	    idn_flags |= IDNA_USE_STD3_ASCII_RULES;
 
 	  char *p = NULL;
-	  rc = __idna_to_ascii_lz (name, &p, idn_flags);
+	  int rc = __idna_to_ascii_lz (name, &p, idn_flags);
 	  if (rc != IDNA_SUCCESS)
 	    {
 	      /* No need to jump to free_and_return here.  */
@@ -598,14 +589,13 @@ gaih_inet (const char *name, const struct gaih_service *service,
 	      int rc;
 	      struct hostent th;
 	      struct hostent *h;
-	      int herrno;
 
 	      while (1)
 		{
 		  rc = __gethostbyname2_r (name, AF_INET, &th,
 					   tmpbuf->data, tmpbuf->length,
-					   &h, &herrno);
-		  if (rc != ERANGE || herrno != NETDB_INTERNAL)
+					   &h, &h_errno);
+		  if (rc != ERANGE || h_errno != NETDB_INTERNAL)
 		    break;
 		  if (!scratch_buffer_grow (tmpbuf))
 		    {
@@ -627,15 +617,20 @@ gaih_inet (const char *name, const struct gaih_service *service,
 			}
 		      *pat = addrmem;
 		    }
+		  else
+		    {
+		      if (h_errno == NO_DATA)
+			result = -EAI_NODATA;
+		      else
+			result = -EAI_NONAME;
+		      goto free_and_return;
+		    }
 		}
 	      else
 		{
-		  if (herrno == NETDB_INTERNAL)
-		    {
-		      __set_h_errno (herrno);
-		      result = -EAI_SYSTEM;
-		    }
-		  else if (herrno == TRY_AGAIN)
+		  if (h_errno == NETDB_INTERNAL)
+		    result = -EAI_SYSTEM;
+		  else if (h_errno == TRY_AGAIN)
 		    result = -EAI_AGAIN;
 		  else
 		    /* We made requests but they turned out no data.
@@ -658,8 +653,7 @@ gaih_inet (const char *name, const struct gaih_service *service,
 	    {
 	      /* Try to use nscd.  */
 	      struct nscd_ai_result *air = NULL;
-	      int herrno;
-	      int err = __nscd_getai (name, &air, &herrno);
+	      int err = __nscd_getai (name, &air, &h_errno);
 	      if (air != NULL)
 		{
 		  /* Transform into gaih_addrtuple list.  */
@@ -750,9 +744,9 @@ gaih_inet (const char *name, const struct gaih_service *service,
 		goto free_and_return;
 	      else if (__nss_not_use_nscd_hosts == 0)
 		{
-		  if (herrno == NETDB_INTERNAL && errno == ENOMEM)
+		  if (h_errno == NETDB_INTERNAL && errno == ENOMEM)
 		    result = -EAI_MEMORY;
-		  else if (herrno == TRY_AGAIN)
+		  else if (h_errno == TRY_AGAIN)
 		    result = -EAI_AGAIN;
 		  else
 		    result = -EAI_SYSTEM;
@@ -791,24 +785,21 @@ gaih_inet (const char *name, const struct gaih_service *service,
 
 	      if (fct4 != NULL)
 		{
-		  int herrno;
-
 		  while (1)
 		    {
-		      rc = 0;
 		      status = DL_CALL_FCT (fct4, (name, pat,
 						   tmpbuf->data, tmpbuf->length,
-						   &rc, &herrno,
+						   &errno, &h_errno,
 						   NULL));
 		      if (status == NSS_STATUS_SUCCESS)
 			break;
 		      if (status != NSS_STATUS_TRYAGAIN
-			  || rc != ERANGE || herrno != NETDB_INTERNAL)
+			  || errno != ERANGE || h_errno != NETDB_INTERNAL)
 			{
-			  if (herrno == TRY_AGAIN)
+			  if (h_errno == TRY_AGAIN)
 			    no_data = EAI_AGAIN;
 			  else
-			    no_data = herrno == NO_DATA;
+			    no_data = h_errno == NO_DATA;
 			  break;
 			}
 
@@ -938,13 +929,17 @@ gaih_inet (const char *name, const struct gaih_service *service,
 		    }
 		  else
 		    {
+		      /* Could not locate any of the lookup functions.
+			 The NSS lookup code does not consistently set
+			 errno, so we need to supply our own error
+			 code here.  The root cause could either be a
+			 resource allocation failure, or a missing
+			 service function in the DSO (so it should not
+			 be listed in /etc/nsswitch.conf).  Assume the
+			 former, and return EBUSY.  */
 		      status = NSS_STATUS_UNAVAIL;
-		      /* Could not load any of the lookup functions.  Indicate
-		         an internal error if the failure was due to a system
-			 error other than the file not being found.  We use the
-			 errno from the last failed callback.  */
-		      if (errno != 0 && errno != ENOENT)
-			__set_h_errno (NETDB_INTERNAL);
+		     __set_h_errno (NETDB_INTERNAL);
+		     __set_errno (EBUSY);
 		    }
 		}
 
@@ -960,7 +955,10 @@ gaih_inet (const char *name, const struct gaih_service *service,
 	  __resolv_context_enable_inet6 (res_ctx, res_enable_inet6);
 	  __resolv_context_put (res_ctx);
 
-	  if (h_errno == NETDB_INTERNAL)
+	  /* If we have a failure which sets errno, report it using
+	     EAI_SYSTEM.  */
+	  if ((status == NSS_STATUS_TRYAGAIN || status == NSS_STATUS_UNAVAIL)
+	      && h_errno == NETDB_INTERNAL)
 	    {
 	      result = -EAI_SYSTEM;
 	      goto free_and_return;
diff --git a/sysdeps/posix/preadv2.c b/sysdeps/posix/preadv2.c
index 2a7cf11e27..d27f7028ed 100644
--- a/sysdeps/posix/preadv2.c
+++ b/sysdeps/posix/preadv2.c
@@ -28,7 +28,7 @@ preadv2 (int fd, const struct iovec *vector, int count, OFF_T offset,
 {
   if (flags != 0)
     {
-      __set_errno (EOPNOTSUPP);
+      __set_errno (ENOTSUP);
       return -1;
     }
 
diff --git a/sysdeps/posix/preadv64v2.c b/sysdeps/posix/preadv64v2.c
index e084f3f9e1..ce7cb40bf2 100644
--- a/sysdeps/posix/preadv64v2.c
+++ b/sysdeps/posix/preadv64v2.c
@@ -25,7 +25,7 @@ preadv64v2 (int fd, const struct iovec *vector, int count, OFF_T offset,
 {
   if (flags != 0)
     {
-      __set_errno (EOPNOTSUPP);
+      __set_errno (ENOTSUP);
       return -1;
     }
 
diff --git a/sysdeps/posix/pwritev2.c b/sysdeps/posix/pwritev2.c
index 5b7650c4fc..7ec8cbc407 100644
--- a/sysdeps/posix/pwritev2.c
+++ b/sysdeps/posix/pwritev2.c
@@ -28,7 +28,7 @@ pwritev2 (int fd, const struct iovec *vector, int count, OFF_T offset,
 {
   if (flags != 0)
     {
-      __set_errno (EOPNOTSUPP);
+      __set_errno (ENOTSUP);
       return -1;
     }
 
diff --git a/sysdeps/posix/pwritev64v2.c b/sysdeps/posix/pwritev64v2.c
index 0f2f9ef863..be98aeed9d 100644
--- a/sysdeps/posix/pwritev64v2.c
+++ b/sysdeps/posix/pwritev64v2.c
@@ -26,7 +26,7 @@ pwritev64v2 (int fd, const struct iovec *vector, int count, OFF_T offset,
 {
   if (flags != 0)
     {
-      __set_errno (EOPNOTSUPP);
+      __set_errno (ENOTSUP);
       return -1;
     }
 
diff --git a/sysdeps/powerpc/fpu/math_private.h b/sysdeps/powerpc/fpu/math_private.h
index d8fd4923ac..396fd0562e 100644
--- a/sysdeps/powerpc/fpu/math_private.h
+++ b/sysdeps/powerpc/fpu/math_private.h
@@ -30,7 +30,7 @@ extern __always_inline _Float128
 __ieee754_sqrtf128 (_Float128 __x)
 {
   _Float128 __z;
-  asm ("xssqrtqp %0,%1" : "=wq" (__z) : "wq" (__x));
+  asm ("xssqrtqp %0,%1" : "=v" (__z) : "v" (__x));
   return __z;
 }
 #endif
diff --git a/sysdeps/powerpc/powerpc64le/Makefile b/sysdeps/powerpc/powerpc64le/Makefile
index 77617b670a..dea2290736 100644
--- a/sysdeps/powerpc/powerpc64le/Makefile
+++ b/sysdeps/powerpc/powerpc64le/Makefile
@@ -16,7 +16,9 @@ $(foreach suf,$(all-object-suffixes),%f128_r$(suf)): CFLAGS += -mfloat128
 $(foreach suf,$(all-object-suffixes),$(objpfx)test-float128%$(suf)): CFLAGS += -mfloat128
 $(foreach suf,$(all-object-suffixes),$(objpfx)test-ifloat128%$(suf)): CFLAGS += -mfloat128
 CFLAGS-libm-test-support-float128.c += -mfloat128
-$(objpfx)test-float128% $(objpfx)test-ifloat128%: \
+CFLAGS-test-math-issignaling.cc += -mfloat128
+CFLAGS-test-math-iszero.cc += -mfloat128
+$(objpfx)test-float128% $(objpfx)test-ifloat128% $(objpfx)test-math-iszero: \
   gnulib-tests += $(f128-loader-link)
 endif
 
diff --git a/sysdeps/powerpc/powerpc64le/power9/fpu/e_sqrtf128.c b/sysdeps/powerpc/powerpc64le/power9/fpu/e_sqrtf128.c
index 769d3f8922..59fd8269f5 100644
--- a/sysdeps/powerpc/powerpc64le/power9/fpu/e_sqrtf128.c
+++ b/sysdeps/powerpc/powerpc64le/power9/fpu/e_sqrtf128.c
@@ -30,7 +30,7 @@ __float128
 __ieee754_sqrtf128 (__float128 a)
 {
   __float128 z;
-  asm ("xssqrtqp %0,%1" : "=wq" (z) : "wq" (a));
+  asm ("xssqrtqp %0,%1" : "=v" (z) : "v" (a));
   return z;
 }
 strong_alias (__ieee754_sqrtf128, __sqrtf128_finite)
diff --git a/sysdeps/unix/sysv/linux/preadv2.c b/sysdeps/unix/sysv/linux/preadv2.c
index 11fe85eaa8..137e2dd791 100644
--- a/sysdeps/unix/sysv/linux/preadv2.c
+++ b/sysdeps/unix/sysv/linux/preadv2.c
@@ -32,7 +32,7 @@ preadv2 (int fd, const struct iovec *vector, int count, off_t offset,
 # ifdef __NR_preadv2
   ssize_t result = SYSCALL_CANCEL (preadv2, fd, vector, count,
 				   LO_HI_LONG (offset), flags);
-  if (result >= 0 || errno != ENOSYS)
+  if (result >= 0)
     return result;
 # endif
   /* Trying to emulate the preadv2 syscall flags is troublesome:
@@ -46,7 +46,7 @@ preadv2 (int fd, const struct iovec *vector, int count, off_t offset,
 
   if (flags != 0)
     {
-      __set_errno (EOPNOTSUPP);
+      __set_errno (ENOTSUP);
       return -1;
     }
   return preadv (fd, vector, count, offset);
diff --git a/sysdeps/unix/sysv/linux/preadv64v2.c b/sysdeps/unix/sysv/linux/preadv64v2.c
index 9d7f8c9893..8f413253f4 100644
--- a/sysdeps/unix/sysv/linux/preadv64v2.c
+++ b/sysdeps/unix/sysv/linux/preadv64v2.c
@@ -30,7 +30,7 @@ preadv64v2 (int fd, const struct iovec *vector, int count, off64_t offset,
 #ifdef __NR_preadv64v2
   ssize_t result = SYSCALL_CANCEL (preadv64v2, fd, vector, count,
 				   LO_HI_LONG (offset), flags);
-  if (result >= 0 || errno != ENOSYS)
+  if (result >= 0)
     return result;
 #endif
   /* Trying to emulate the preadv2 syscall flags is troublesome:
@@ -44,7 +44,7 @@ preadv64v2 (int fd, const struct iovec *vector, int count, off64_t offset,
 
   if (flags != 0)
     {
-      __set_errno (EOPNOTSUPP);
+      __set_errno (ENOTSUP);
       return -1;
     }
   return preadv64 (fd, vector, count, offset);
diff --git a/sysdeps/unix/sysv/linux/pwritev2.c b/sysdeps/unix/sysv/linux/pwritev2.c
index 72f0471f96..8e5032fe2f 100644
--- a/sysdeps/unix/sysv/linux/pwritev2.c
+++ b/sysdeps/unix/sysv/linux/pwritev2.c
@@ -28,7 +28,7 @@ pwritev2 (int fd, const struct iovec *vector, int count, off_t offset,
 # ifdef __NR_pwritev2
   ssize_t result = SYSCALL_CANCEL (pwritev2, fd, vector, count,
 				   LO_HI_LONG (offset), flags);
-  if (result >= 0 || errno != ENOSYS)
+  if (result >= 0)
     return result;
 # endif
   /* Trying to emulate the pwritev2 syscall flags is troublesome:
@@ -42,7 +42,7 @@ pwritev2 (int fd, const struct iovec *vector, int count, off_t offset,
 
   if (flags != 0)
     {
-      __set_errno (EOPNOTSUPP);
+      __set_errno (ENOTSUP);
       return -1;
     }
   return pwritev (fd, vector, count, offset);
diff --git a/sysdeps/unix/sysv/linux/pwritev64v2.c b/sysdeps/unix/sysv/linux/pwritev64v2.c
index def9a0bc57..d2800c6657 100644
--- a/sysdeps/unix/sysv/linux/pwritev64v2.c
+++ b/sysdeps/unix/sysv/linux/pwritev64v2.c
@@ -30,7 +30,7 @@ pwritev64v2 (int fd, const struct iovec *vector, int count, off64_t offset,
 #ifdef __NR_pwritev64v2
   ssize_t result = SYSCALL_CANCEL (pwritev64v2, fd, vector, count,
 				   LO_HI_LONG (offset), flags);
-  if (result >= 0 || errno != ENOSYS)
+  if (result >= 0)
     return result;
 #endif
   /* Trying to emulate the pwritev2 syscall flags is troublesome:
@@ -44,7 +44,7 @@ pwritev64v2 (int fd, const struct iovec *vector, int count, off64_t offset,
 
   if (flags != 0)
     {
-      __set_errno (EOPNOTSUPP);
+      __set_errno (ENOTSUP);
       return -1;
     }
   return pwritev64 (fd, vector, count, offset);
diff --git a/sysdeps/x86/cpu-features.c b/sysdeps/x86/cpu-features.c
index 1d087ea732..6f900840d4 100644
--- a/sysdeps/x86/cpu-features.c
+++ b/sysdeps/x86/cpu-features.c
@@ -244,10 +244,13 @@ init_cpu_features (struct cpu_features *cpu_features)
 	  |= bit_arch_Prefer_No_AVX512;
 
       /* To avoid SSE transition penalty, use _dl_runtime_resolve_slow.
-         If XGETBV suports ECX == 1, use _dl_runtime_resolve_opt.  */
+         If XGETBV suports ECX == 1, use _dl_runtime_resolve_opt.
+	 Use _dl_runtime_resolve_opt only with AVX512F since it is
+	 slower than _dl_runtime_resolve_slow with AVX.  */
       cpu_features->feature[index_arch_Use_dl_runtime_resolve_slow]
 	|= bit_arch_Use_dl_runtime_resolve_slow;
-      if (cpu_features->max_cpuid >= 0xd)
+      if (CPU_FEATURES_ARCH_P (cpu_features, AVX512F_Usable)
+	  && cpu_features->max_cpuid >= 0xd)
 	{
 	  unsigned int eax;
 
diff --git a/sysdeps/x86_64/fpu/libm-test-ulps b/sysdeps/x86_64/fpu/libm-test-ulps
index c347642044..1e28aaa9f1 100644
--- a/sysdeps/x86_64/fpu/libm-test-ulps
+++ b/sysdeps/x86_64/fpu/libm-test-ulps
@@ -1733,10 +1733,10 @@ ldouble: 3
 
 Function: Imaginary part of "ctan_upward":
 double: 2
-float: 1
+float: 2
 float128: 5
 idouble: 2
-ifloat: 1
+ifloat: 2
 ifloat128: 5
 ildouble: 3
 ldouble: 3
